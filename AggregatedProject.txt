

--- File: build.gradle ---

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        gradlePluginPortal()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        google()
    }
    dependencies {

    }
}

allprojects {
    apply plugin: "eclipse"

    version = '1.0'
    ext {
        appName = "Bomber Quest"
        gdxVersion = '1.13.0'
        roboVMVersion = '2.3.20'
        box2DLightsVersion = '1.5'
        ashleyVersion = '1.7.4'
        aiVersion = '1.8.2'
        gdxControllersVersion = '2.2.1'
        gdxNativefilechooserVersion = '2.3.0'
    }

    repositories {
        mavenLocal()
        mavenCentral()
        google()
        gradlePluginPortal()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
        maven { url "https://jitpack.io" }
    }

    tasks.withType(JavaCompile).configureEach {
        javaCompiler = javaToolchains.compilerFor {
            languageVersion = JavaLanguageVersion.of(17)
        }
    }
}

project(":desktop") {
    apply plugin: "java-library"

    dependencies {
        implementation project(":core")
        api "com.badlogicgames.gdx:gdx-backend-lwjgl3:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
        api "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-desktop"
        implementation "games.spooky.gdx:gdx-nativefilechooser-desktop-lwjgl:$gdxNativefilechooserVersion"
        api "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-desktop"
    }
}

project(":core") {
    apply plugin: "java-library"

    dependencies {
        api "com.badlogicgames.gdx:gdx:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
        implementation "games.spooky.gdx:gdx-nativefilechooser:$gdxNativefilechooserVersion"
        api "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
    }
}


--- File: settings.gradle ---

include 'desktop', 'core'

--- File: core/build.gradle ---

java {
    sourceCompatibility = JavaVersion.VERSION_17
}
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

sourceSets.main.java.srcDirs = [ "src/" ]

eclipse.project.name = appName + "-core"


--- File: core/src/de/tum/cit/ase/bomberquest/BomberQuestGame.java ---

package de.tum.cit.ase.bomberquest;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import de.tum.cit.ase.bomberquest.audio.MusicTrack;
import de.tum.cit.ase.bomberquest.map.DestructibleWall;
import de.tum.cit.ase.bomberquest.map.Entrance;
import de.tum.cit.ase.bomberquest.map.GameMap;
import de.tum.cit.ase.bomberquest.map.IndestructibleWall;
import de.tum.cit.ase.bomberquest.screen.GameScreen;
import de.tum.cit.ase.bomberquest.screen.MenuScreen;
import de.tum.cit.ase.bomberquest.texture.Textures;
import games.spooky.gdx.nativefilechooser.NativeFileChooser;

/**
 * The BomberQuestGame class represents the core of the Bomber Quest game.
 * It manages the screens and global resources like SpriteBatch and Skin.
 */
public class BomberQuestGame extends Game {

    /**
     * Sprite Batch for rendering game elements.
     * This eats a lot of memory, so we only want one of these.
     */
    private SpriteBatch spriteBatch;

    /** The game's UI skin. This is used to style the game's UI elements. */
    private Skin skin;

    /**
     * The file chooser for loading map files from the user's computer.
     * This will give you access to a {@link com.badlogic.gdx.files.FileHandle} object,
     * which you can use to read the contents of the map file as a String, and then parse it into a {@link GameMap}.
     */
    private final NativeFileChooser fileChooser;

    /**
     * The map. This is where all the game objects are stored.
     * This is owned by {@link BomberQuestGame} and not by {@link GameScreen}
     * because the map should not be destroyed if we temporarily switch to another screen.
     */
    private GameMap map;

    /**
     * Constructor for BomberQuestGame.
     *
     * @param fileChooser The file chooser for selecting custom maps.
     */
    public BomberQuestGame(NativeFileChooser fileChooser) {
        this.fileChooser = fileChooser;
    }

    /**
     * Called when the game is created. Initializes the SpriteBatch and Skin.
     * During the class constructor, libGDX is not fully initialized yet.
     * Therefore this method serves as a second constructor for the game,
     * and we can use libGDX resources here.
     */
    @Override
    public void create() {
        this.spriteBatch = new SpriteBatch(); // Create SpriteBatch for rendering
        this.skin = new Skin(Gdx.files.internal("skin/craftacular/craftacular-ui.json")); // Load UI skin
        this.map = new GameMap(this); // Create a new game map (you should change this to load the map from a file instead)
        this.map.loadFromProperties("maps/map.properties");
        MusicTrack.BACKGROUND.play(); // Play some background music
        goToMenu(); // Navigate to the menu screen
    }

    /**
     * Switches to the menu screen.
     */
    public void goToMenu() {
        this.setScreen(new MenuScreen(this)); // Set the current screen to MenuScreen
    }

    /**
     * Switches to the game screen.
     */
    public void goToGame() {
        this.setScreen(new GameScreen(this)); // Set the current screen to GameScreen
    }

    /** Returns the skin for UI elements. */
    public Skin getSkin() {
        return skin;
    }

    /** Returns the main SpriteBatch for rendering. */
    public SpriteBatch getSpriteBatch() {
        return spriteBatch;
    }

    /** Returns the current map, if there is one. */
    public GameMap getMap() {
        return map;
    }

    /**
     * Switches to the given screen and disposes of the previous screen.
     * @param screen the new screen
     */
    @Override
    public void setScreen(Screen screen) {
        Screen previousScreen = super.screen;
        super.setScreen(screen);
        if (previousScreen != null) {
            previousScreen.dispose();
        }
    }

    /** Cleans up resources when the game is disposed. */
    @Override
    public void dispose() {
        getScreen().hide(); // Hide the current screen
        getScreen().dispose(); // Dispose the current screen
        spriteBatch.dispose(); // Dispose the spriteBatch
        skin.dispose(); // Dispose the skin
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/audio/MusicTrack.java ---

package de.tum.cit.ase.bomberquest.audio;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;

/**
 * This enum is used to manage the music tracks in the game.
 * Currently, only one track is used, but this could be extended to include multiple tracks.
 * Using an enum for this purpose is a good practice, as it allows for easy management of the music tracks
 * and prevents the same track from being loaded into memory multiple times.
 * See the assets/audio folder for the actual music files.
 * Feel free to add your own music tracks and use them in the game!
 */
public enum MusicTrack {
    
    BACKGROUND("background.mp3", 0.2f);
    
    /** The music file owned by this variant. */
    private final Music music;
    
    MusicTrack(String fileName, float volume) {
        this.music = Gdx.audio.newMusic(Gdx.files.internal("audio/" + fileName));
        this.music.setLooping(true);
        this.music.setVolume(volume);
    }
    
    /**
     * Play this music track.
     * This will not stop other music from playing - if you add more tracks, you will have to handle that yourself.
     */
    public void play() {
        this.music.play();
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Enemy.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents an enemy in the game.
 * Enemies can move and interact with bombs and players.
 */
public class Enemy extends Object implements Drawable {


    private final Body body;
    private final TextureRegion textureRegion;
    private static final float ENEMY_SIZE = 1.0f;

    public Enemy() {
        super(0, 0, null);
        this.textureRegion = null;
        this.body = null;
    }

    public Enemy(World world, float x, float y, int type, TextureRegion textureRegion) {
        super(x, y, null);
        this.textureRegion = textureRegion;

        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.DynamicBody;
        bodyDef.position.set(x, y);

        body = world.createBody(bodyDef);


        PolygonShape shape = new PolygonShape();
        shape.setAsBox(ENEMY_SIZE / 2, ENEMY_SIZE / 2);
        body.createFixture(shape, 1.0f);
        shape.dispose();
    }

    /**
     * Renders the enemy on the screen.
     *
     * @param batch The SpriteBatch used for rendering.
     */

    public void render(SpriteBatch batch) {
        Vector2 position = body.getPosition();
        batch.draw(textureRegion, position.x - ENEMY_SIZE / 2, position.y - ENEMY_SIZE / 2, ENEMY_SIZE, ENEMY_SIZE);
    }



    /**
     * Updates the enemy's state.
     *
     * @param deltaTime The time elapsed since the last frame.
     */

    public void update(float deltaTime) {

    }

    public Body getBody() {
        return body;
    }



     @Override
     public TextureRegion getCurrentAppearance() {
         // just return this.textureRegion
         return textureRegion;
     }

     @Override
     public float getX() {
         return x;  // ‘x’ is inherited from parent
     }

     @Override
     public float getY() {
         return y;
     }

}



--- File: core/src/de/tum/cit/ase/bomberquest/map/Flowers.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import de.tum.cit.ase.bomberquest.texture.Drawable;
import de.tum.cit.ase.bomberquest.texture.Textures;

/**
 * Flowers are a static object without any special properties.
 * They do not have a hitbox, so the player does not collide with them.
 * They are purely decorative and serve as a nice floor decoration.
 */
public class Flowers implements Drawable {
    
    private final int x;
    private final int y;
    
    public Flowers(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public TextureRegion getCurrentAppearance() {
        return Textures.FLOWERS;
    }
    
    @Override
    public float getX() {
        return x;
    }
    
    @Override
    public float getY() {
        return y;
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/map/PowerUp.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents a power-up in the game.
 * Power-ups can be collected by the player to enhance abilities.
 */
public class PowerUp extends Object implements Drawable{

        private final Body body;
        private final TextureRegion textureRegion;
        private final int type; // 5 for concurrent bomb, 6 for blast radius
        private static final float POWERUP_SIZE = 1.0f;

        public PowerUp(World world, float x, float y, int type, TextureRegion textureRegion) {
            super(x, y, null);
            this.type = type;
            this.textureRegion = textureRegion;

            BodyDef bodyDef = new BodyDef();
            bodyDef.type = BodyDef.BodyType.StaticBody;
            bodyDef.position.set(x, y);


            body = world.createBody(bodyDef);


            PolygonShape shape = new PolygonShape();
            shape.setAsBox(POWERUP_SIZE / 2, POWERUP_SIZE / 2);
            body.createFixture(shape, 0.0f);
            shape.dispose();
        }



        /**
         * Renders the power-up on the screen.
         *
         * @param batch The SpriteBatch used for rendering.
         */

    public void render(SpriteBatch batch) {
        Vector2 position = body.getPosition();
        batch.draw(textureRegion, position.x - POWERUP_SIZE / 2, position.y - POWERUP_SIZE / 2, POWERUP_SIZE, POWERUP_SIZE);
    }



    /**
     * Gets the type of the power-up.
     *
     * @return The type of the power-up.
     */

    public int getType() {
        return type;
    }
    @Override
    public TextureRegion getCurrentAppearance() {
        // just return this.textureRegion
        return textureRegion;
    }

    @Override
    public float getX() {
        return x;  // ‘x’ is inherited from parent
    }

    @Override
    public float getY() {
        return y;
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/map/DestructibleWall.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.World;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * DestructibleWall is a subclass of WallPath that can be destroyed.
 */
public class DestructibleWall extends WallPath {

    /**
     * Constructs a DestructibleWall with the specified position, dimensions, and texture region.
     *
     * @param x             The initial x-coordinate of the wall.
     * @param y             The initial y-coordinate of the wall.
     * @param width         The width of the wall.
     * @param height        The height of the wall.
     * @param textureRegion The TextureRegion for the static appearance of the wall.
     */
    public DestructibleWall(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(world, x, y, width, height, textureRegion);
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return True because this is a destructible wall.
     */
    @Override
    public boolean isDestructible() {
        return true;
    }

    /**
     * Destroys the wall/path by setting the isDestroyed flag to true.
     */
    @Override
    public void destroy() {
        if (!isDestroyed) {
            this.isDestroyed = true;
            body.getWorld().destroyBody(body);
        }
    }
}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Object.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;

/**
 * The GameObject class serves as a base class for game objects in the scene.(Enemy, Entrance, Exit)
 * It extends the LibGDX Actor class and provides common properties and methods for game objects.
 *
 * @see com.badlogic.gdx.scenes.scene2d.Actor
 */
public class Object extends Actor {

    /** The x-coordinate of the game object. */
    protected float x;

    /** The y-coordinate of the game object. */
    protected float y;

    /** The width of the game object. */
    protected float width = 64;

    /** The height of the game object. */
    protected float height = 64;

    /** The animation used for dynamic game objects. */
    protected Animation<TextureRegion> animation;

    /** The current animation time for dynamic game objects. */
    protected float animationTime = 0;

    /** The sinus input used for certain animations or behaviors. */
    protected float sinusInput = 0f;

    /** The texture region representing the visual appearance of the game object. */
    protected TextureRegion textureRegion;

    /** The texture of the game object (might be null if using animation). */
    protected Texture texture;

    /** The speed of the game object (might be used in subclasses). */
    protected float speed;

    /**
     * Constructs a GameObject with the specified position, dimensions, and animation.
     *
     * @param x           The x-coordinate of the game object.
     * @param y           The y-coordinate of the game object.
     * @param animation   The animation for dynamic game objects.
     */
    public Object(float x, float y, Animation<TextureRegion> animation) {
        this.x = x;
        this.y = y;
        this.animation = animation;
    }


    /**
     * Checks if this game object collides with another game object.
     *
     * @param object  The other game object to check for collision.
     * @return True if a collision occurs, false otherwise.
     */
    public boolean collidesWith(Object object) {
        boolean above = y + height - 20 > object.getY();
        boolean below = y + 10 < object.getY() + object.getHeight();
        boolean left = x + 3 < object.getX() + object.getWidth();
        boolean right = x + width > object.getX();
        return above && below && left && right;
    }

    /**
     * Draws the game object using the specified SpriteBatch, position, dimensions, and delta time.
     *
     * @param batch   The SpriteBatch used for drawing.
     * @param x       The x-coordinate at which to draw the game object.
     * @param y       The y-coordinate at which to draw the game object.
     * @param delta   The time elapsed since the last draw.
     * @param width   The width at which to draw the game object.
     * @param height  The height at which to draw the game object.
     */
    public void draw(SpriteBatch batch, float x, float y, float delta, float width, float height) {
        animationTime += delta;
        TextureRegion currentFrame = animation.getKeyFrame(animationTime, true);
        batch.draw(currentFrame, x, y, width, height);
    }

    /**
     * Updates the game object based on the elapsed time since the last update.
     *
     * @param delta  The time elapsed since the last update.
     */
    public void update(float delta) {
    }

    // Getters and setters
    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public float getWidth() {
        return width;
    }

    public float getHeight() {
        return height;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void setWidth(float width) {
        this.width = width;
    }

    public void setHeight(float height) {
        this.height = height;
    }

    public float getSinusInput() {
        return sinusInput;
    }

    public TextureRegion getTextureRegion() {
        return textureRegion;
    }

    public Texture getTexture() {
        return texture;
    }

    public float getSpeed() {
        return speed;
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/IndestructibleWall.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.World;

/**
 * IndestructibleWall is a subclass of WallPath that cannot be destroyed.
 */
public class IndestructibleWall extends WallPath  {

    /**
     * Constructs an IndestructibleWall with the specified position, dimensions, and texture region.
     *
     * @param x             The initial x-coordinate of the wall.
     * @param y             The initial y-coordinate of the wall.
     * @param width         The width of the wall.
     * @param height        The height of the wall.
     * @param textureRegion The TextureRegion for the static appearance of the wall.
     */
    public IndestructibleWall(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(world, x, y, width, height, textureRegion);
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return False because this is an indestructible wall.
     */
    @Override
    public boolean isDestructible() {
        return false;
    }

    /**
     * Indestructible walls cannot be destroyed, so this method does nothing.
     */
    @Override
    public void destroy() {
        // No action needed for indestructible walls.
    }

}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Entrance.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * The Entrance class represents the starting point of the player in the game.
 * It extends the Object class and provides functionality specific to the entrance object.
 *
 * The Entrance serves as the spawn point for the player at the beginning of the game.
 * It is visually represented by a texture and does not require any dynamic animation.
 *
 * @see Object
 */
public class Entrance extends Object implements Drawable {

    /**
     * Constructs an Entrance object with the specified position and texture region.
     *
     * @param x             The x-coordinate of the entrance.
     * @param y             The y-coordinate of the entrance.
     * @param textureRegion The texture region representing the entrance's visual appearance.
     */
    public Entrance(float x, float y, TextureRegion textureRegion) {
        super(x, y, null); // No animation needed for the Entrance.
        this.textureRegion = textureRegion; // Set the visual representation of the entrance.
        this.width = 64; // Default width
        this.height = 64; // Default height
    }

    /**
     * Draws the entrance using the specified SpriteBatch and dimensions.
     *
     * @param batch The SpriteBatch used for rendering the entrance.
     * @param delta The time elapsed since the last draw.
     */

    public void draw(SpriteBatch batch, float delta) {
        if (textureRegion != null) {
            batch.draw(textureRegion, x, y, width, height);
        }
    }

    /**
     * Updates the entrance object.
     * Since the entrance does not have dynamic behavior, this method is empty.
     *
     * @param delta The time elapsed since the last update.
     */
    @Override
    public void update(float delta) {
        // No dynamic updates needed for the entrance.
    }

    @Override
    public TextureRegion getCurrentAppearance() {
        // just return this.textureRegion
        return textureRegion;
    }

    @Override
    public float getX() {
        return x;  // ‘x’ is inherited from parent
    }

    @Override
    public float getY() {
        return y;
    }
}

--- File: core/src/de/tum/cit/ase/bomberquest/map/GameMap.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.World;
import de.tum.cit.ase.bomberquest.BomberQuestGame;
import de.tum.cit.ase.bomberquest.texture.Textures;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Represents the game map.
 * Holds all the objects and entities in the game.
 */
public class GameMap {

    // A static block is executed once when the class is referenced for the first time.
    static {
        // Initialize the Box2D physics engine.
        com.badlogic.gdx.physics.box2d.Box2D.init();
    }

    // Box2D physics simulation parameters (you can experiment with these if you want, but they work well as they are)
    /**
     * The time step for the physics simulation.
     * This is the amount of time that the physics simulation advances by in each frame.
     * It is set to 1/refreshRate, where refreshRate is the refresh rate of the monitor, e.g., 1/60 for 60 Hz.
     */
    private static final float TIME_STEP = 1f / Gdx.graphics.getDisplayMode().refreshRate;
    /** The number of velocity iterations for the physics simulation. */
    private static final int VELOCITY_ITERATIONS = 6;
    /** The number of position iterations for the physics simulation. */
    private static final int POSITION_ITERATIONS = 2;
    /**
     * The accumulated time since the last physics step.
     * We use this to keep the physics simulation at a constant rate even if the frame rate is variable.
     */
    private float physicsTime = 0;

    /** The game, in case the map needs to access it. */
    private final BomberQuestGame game;
    /** The Box2D world for physics simulation. */
    private final World world;

    // Game objects
    private final Player player;
    private Entrance entrance;
    private Exit exit;
    private final Chest chest;

    private final Flowers[][] flowers;

    private final List<WallPath> walls;
    private List<Enemy> enemies;
    private final List<PowerUp> powerUps = new ArrayList<>();
    private Texture indestructibleWallTexture;
    private Texture destructibleWallTexture;

    public GameMap(BomberQuestGame game) {
        this.game = game;
        this.world = new World(Vector2.Zero, true);

        this.entrance = null;
        this.exit = null;

        // Create the player (so we have it ready for when the entrance is parsed).
        this.player = new Player(this.world, 0, 0);

        this.enemies = new ArrayList<>();

        // Initialize empty data structures:
        this.walls = new ArrayList<>();
        this.chest= null;
        this.entrance = null;
        this.flowers = new Flowers[1][4];

        indestructibleWallTexture = new Texture("assets/texture/ind.png");
        destructibleWallTexture = new Texture("assets/texture/destructablewall.png");
    }

    public Entrance getEntrance() {
        return entrance;
    }

    public Exit getExit() {
        return exit;
    }

    public List<Enemy> getEnemies() {
        return enemies;
    }

    public List<PowerUp> getPowerUps() {
        return powerUps;
    }


    /**
     * Updates the game state. This is called once per frame.
     * Every dynamic object in the game should update its state here.
     * @param frameTime the time that has passed since the last update
     */
    public void tick(float frameTime) {
        this.player.tick(frameTime);
        doPhysicsStep(frameTime);

        // If we have an exit and it’s not unlocked yet, check if all enemies are dead
        if (exit != null && !exit.isUnlocked() && allEnemiesDead()) {
            exit.unlockExit();
        }
    }

    private boolean allEnemiesDead() {
        // If you remove enemies from `enemies` when they die, this is as simple as checking size=0
        // Or check an isAlive flag in each enemy if you keep them around.
        return enemies.isEmpty();
    }


    /**
     * Performs as many physics steps as necessary to catch up to the given frame time.
     * This will update the Box2D world by the given time step.
     * @param frameTime Time since last frame in seconds
     */
    private void doPhysicsStep(float frameTime) {
        this.physicsTime += frameTime;
        while (this.physicsTime >= TIME_STEP) {
            this.world.step(TIME_STEP, VELOCITY_ITERATIONS, POSITION_ITERATIONS);
            this.physicsTime -= TIME_STEP;
        }

    }

    /** Returns the player on the map. */
    public Player getPlayer() {
        return player;
    }

    /** Returns the chest on the map. */
    public Chest getChest() {
        return chest;
    }

    /** Returns the flowers on the map. */
    public List<Flowers> getFlowers() {
        return Arrays.stream(flowers).flatMap(Arrays::stream).toList();
    }
    public List<WallPath> getWalls() {
        return walls;
    }

    public void loadFromProperties(String relativePath) {
        String fileContent = Gdx.files.internal(relativePath).readString();
        String[] lines = fileContent.split("\\r?\\n");

        for (String line : lines) {
            line = line.trim();
            if (line.isEmpty() || line.startsWith("#")) {
                continue;
            }

            String[] parts = line.split("=");
            if (parts.length < 2) {
                continue;
            }
            String key = parts[0].trim();
            String val = parts[1].trim();

            // 5. Split key into coordinates x,y
            String[] coords = key.split(",");
            if (coords.length < 2) {
                continue; // malformed coordinates
            }
            int x = Integer.parseInt(coords[0]);
            int y = Integer.parseInt(coords[1]);

            // 6. Parse the object type
            int type = Integer.parseInt(val);

            // 7. Create objects in the Box2D world
            switch (type) {
                case 0:
                    // 0 = Indestructible wall
                    spawnIndestructibleWall(x, y);
                    break;
                case 1:
                    // 1 = Destructible wall
                    spawnDestructibleWall(x, y);
                    break;
                case 2:
                    // 2 = Entrance
                    spawnEntrance(x, y);
                    break;
                case 3:
                    // 3 = Enemy
                    spawnEnemy(x, y);
                    break;
                case 4:
                    // 4 = Exit (with destructible wall on top)
                    spawnExit(x, y);
                    break;
                case 5:
                    // 5 = Concurrent bomb power-up (also under destructible wall)
                    spawnConcurrentPowerUp(x, y);
                    break;
                case 6:
                    // 6 = Blast radius power-up (also under destructible wall)
                    spawnBlastRadiusPowerUp(x, y);
                    break;
                default:
                    System.out.println("Unknown map object type: " + type);
                    break;
            }
        }

        // 8. If no exit was found, pick a random destructible wall to hide an exit
        //    (only if you want to fulfill the rule that a map might not specify exit).
        ensureExitIfMissing();
    }

        private void spawnIndestructibleWall(int x, int y) {
        TextureRegion wallTexture = new TextureRegion(Textures.INDEST_WALL);
        float wallWidth = 1f;
        float wallHeight = 1f;
        IndestructibleWall wall = new IndestructibleWall(
            this.world, x, y,
            wallWidth, wallHeight,
            wallTexture
        );
        this.walls.add(wall);
    }

    private void spawnDestructibleWall(int x, int y) {
        TextureRegion wallTexture = new TextureRegion(Textures.DEST_WALL);
        float wallWidth = 1f;
        float wallHeight = 1f;
        DestructibleWall wall = new DestructibleWall(
            this.world, x, y,
            wallWidth, wallHeight,
            wallTexture
        );
        this.walls.add(wall);
    }

    private void spawnEntrance(int x, int y) {
        // This sets the player's spawn location or store it separately
        // If you want only 1 entrance, you could do:
        this.entrance = new Entrance(x, y, Textures.ENTRANCE);
        // Possibly position the player here
        this.player.getHitbox().setTransform(x, y, 0);
    }

    private void spawnExit(int x, int y) {
        // 1) Make a destructible wall covering (x, y)
        TextureRegion destructibleRegion = new TextureRegion(
            new Texture("assets/texture/destructablewall.png")
        );
        DestructibleWall coverWall = new DestructibleWall(
            this.world,
            x, y,
            1f, 1f,
            destructibleRegion
        );
        this.walls.add(coverWall);

        // 2) Create an Exit object referencing that wall
        //    The Exit constructor can take the same coordinates plus a reference to the wall
        //    (We pass 'null' for animation or a custom exit texture if you prefer.)
        this.exit = new Exit(x, y, Textures.EXIT, coverWall);
    }

    private void spawnEnemy(int x, int y) {
        // This is a placeholder. You might do real logic like new Enemy(world, x, y, someTexture)
        // For now, let's just store a dummy instance in enemies list.
        TextureRegion concurrencyRegion = new TextureRegion(Textures.ENEMY);
        Enemy e = new Enemy(world, x, y, 3, concurrencyRegion);
        // e.setX(x); e.setY(y); or actual Box2D logic if you prefer
        enemies.add(e);
    }

    private void spawnConcurrentPowerUp(int x, int y) {
        TextureRegion concurrencyRegion = new TextureRegion(Textures.POWER_UP);
        PowerUp p = new PowerUp(world, x, y, 5, concurrencyRegion);
        powerUps.add(p);
    }

    private void spawnBlastRadiusPowerUp(int x, int y) {
        // Same concept as concurrency power-up, but different type.
    }

    private void ensureExitIfMissing() {
        // Check if you spawned an exit at all.
        // If not, pick a random destructible wall from `walls` to place an exit under it.
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Player.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.*;
import de.tum.cit.ase.bomberquest.texture.Animations;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents the player character in the game.
 * The player has a hitbox, so it can collide with other objects in the game.
 */
public class Player implements Drawable {
    
    /** Total time elapsed since the game started. We use this for calculating the player movement and animating it. */
    private float elapsedTime;
    
    /** The Box2D hitbox of the player, used for position and collision detection. */
    private final Body hitbox;
    
    public Player(World world, float x, float y) {
        this.hitbox = createHitbox(world, x, y);
    }
    
    /**
     * Creates a Box2D body for the player.
     * This is what the physics engine uses to move the player around and detect collisions with other bodies.
     * @param world The Box2D world to add the body to.
     * @param startX The initial X position.
     * @param startY The initial Y position.
     * @return The created body.
     */
    private Body createHitbox(World world, float startX, float startY) {
        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.DynamicBody;
        bodyDef.position.set(startX, startY);
        Body body = world.createBody(bodyDef);

        CircleShape circle = new CircleShape();
        circle.setRadius(0.3f);

        FixtureDef fixtureDef = new FixtureDef();
        fixtureDef.shape = circle;
        fixtureDef.density = 1.0f;
        fixtureDef.friction = 0.5f;
        fixtureDef.restitution = 0.0f;

        body.createFixture(fixtureDef);
        body.setUserData(this);
        circle.dispose();
        return body;
    }

    /**
     * Move the player around in a circle by updating the linear velocity of its hitbox every frame.
     * This doesn't actually move the player, but it tells the physics engine how the player should move next frame.
     * @param frameTime the time since the last frame.
     */
    public void tick(float frameTime) {
        this.elapsedTime += frameTime;
        float xVelocity = 0;
        float yVelocity = 0;

        if (Gdx.input.isKeyPressed(Input.Keys.UP)) {
            yVelocity = 2;
        } else if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) {
            yVelocity = -2;
        }

        if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) {
            xVelocity = -2;
        } else if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) {
            xVelocity = 2;
        }

        this.hitbox.setLinearVelocity(xVelocity, yVelocity);
    }

    public Body getHitbox() {
        return hitbox;
    }

    
    @Override
    public TextureRegion getCurrentAppearance() {
        // Get the frame of the walk down animation that corresponds to the current time.
        return Animations.CHARACTER_WALK_DOWN.getKeyFrame(this.elapsedTime, true);
    }
    
    @Override
    public float getX() {
        // The x-coordinate of the player is the x-coordinate of the hitbox (this can change every frame).
        return hitbox.getPosition().x;
    }
    
    @Override
    public float getY() {
        // The y-coordinate of the player is the y-coordinate of the hitbox (this can change every frame).
        return hitbox.getPosition().y;
    }
    public void render(SpriteBatch batch) {
        // Get the texture for the player and draw it at the player's current position
        batch.draw(getCurrentAppearance(), getX(), getY(), 1f, 1f);
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Chest.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.*;
import de.tum.cit.ase.bomberquest.texture.Drawable;
import de.tum.cit.ase.bomberquest.texture.Textures;

/**
 * A chest is a static object with a hitbox, so the player cannot walk through it.
 */
public class Chest implements Drawable {
    
    // We would normally get the position from the hitbox, but since we don't need to move the chest, we can store the position directly.
    private final float x;
    private final float y;
    
    /**
     * Create a chest at the given position.
     * @param world The Box2D world to add the chest's hitbox to.
     * @param x The X position.
     * @param y The Y position.
     */
    public Chest(World world, float x, float y) {
        this.x = x;
        this.y = y;
        // Since the hitbox never moves, and we never need to change it, we don't need to store a reference to it.
        createHitbox(world);
    }
    
    /**
     * Create a Box2D body for the chest.
     * @param world The Box2D world to add the body to.
     */
    private void createHitbox(World world) {
        // BodyDef is like a blueprint for the movement properties of the body.
        BodyDef bodyDef = new BodyDef();
        // Static bodies never move, but static bodies can collide with them.
        bodyDef.type = BodyDef.BodyType.StaticBody;
        // Set the initial position of the body.
        bodyDef.position.set(this.x, this.y);
        // Create the body in the world using the body definition.
        Body body = world.createBody(bodyDef);
        // Now we need to give the body a shape so the physics engine knows how to collide with it.
        // We'll use a polygon shape for the chest.
        PolygonShape box = new PolygonShape();
        // Make the polygon a square with a side length of 1 tile.
        box.setAsBox(0.5f, 0.5f);
        // Attach the shape to the body as a fixture.
        body.createFixture(box, 1.0f);
        // We're done with the shape, so we should dispose of it to free up memory.
        box.dispose();
        // Set the chest as the user data of the body so we can look up the chest from the body later.
        body.setUserData(this);
    }
    
    @Override
    public TextureRegion getCurrentAppearance() {
        return Textures.CHEST;
    }
    
    @Override
    public float getX() {
        return x;
    }
    
    @Override
    public float getY() {
        return y;
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/map/WallPath.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.physics.box2d.*;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * WallPath is an abstract class that represents a wall or path in the game map.
 * It no longer uses animation, and it directly handles a static texture.
 */
public abstract class WallPath extends Object implements Drawable{

    private static final float TILE_SIZE = 32.0f;

    protected Rectangle bounds;
    protected TextureRegion textureRegion;
    protected boolean isDestroyed;
    protected final Body body;

    /**
     * Constructs a WallPath object.
     *
     * @param x             X position of the wall/path.
     * @param y             Y position of the wall/path.
     * @param width         Width of the wall/path.
     * @param height        Height of the wall/path.
     * @param textureRegion TextureRegion to render for the wall/path.
     */
    public WallPath(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(x, y, null);  // No animation for the wall, passing null for animation.

        if (textureRegion == null) {
            throw new IllegalArgumentException("TextureRegion cannot be null for WallPath object.");
        }
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Width and height must be positive.");
        }

        this.bounds = new Rectangle(x, y, width, height);
        this.textureRegion = textureRegion;
        this.isDestroyed = false;

        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.StaticBody;
        bodyDef.position.set(x + width / 2, y + height / 2);
        this.body = world.createBody(bodyDef);

        PolygonShape shape = new PolygonShape();
        shape.setAsBox(width / 2, height / 2);

        FixtureDef fixtureDef = new FixtureDef();
        fixtureDef.shape = shape;
        fixtureDef.density = 1.0f;
        fixtureDef.friction = 0.5f;
        fixtureDef.restitution = 0.0f;

        this.body.createFixture(fixtureDef);
        this.body.setUserData(this);

        shape.dispose();
    }

    /**
     * Renders the wall/path if it is not destroyed.
     *
     * @param batch The SpriteBatch used to draw the texture.
     */
    @Override
    public void draw(SpriteBatch batch, float x, float y, float delta, float width, float height) {
        if (!isDestroyed && textureRegion != null) {
            batch.draw(textureRegion, x, y, width, height);
        }
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return True if destructible, false otherwise.
     */
    public abstract boolean isDestructible();

    /**
     * Destroys the wall/path, if applicable.
     */
    public abstract void destroy();

    /**
     * Gets the bounding rectangle for collision or placement purposes.
     *
     * @return The bounds of the wall/path.
     */
    public Rectangle getBounds() {
        return bounds;
    }

    /**
     * Checks if the wall/path has been destroyed.
     *
     * @return True if destroyed, false otherwise.
     */
    public boolean isDestroyed() {
        return isDestroyed;
    }

    /**
     * Disposes of resources associated with this wall/path.
     */
    public void dispose() {
        if (textureRegion != null) {
            // Optionally dispose the texture associated with the texture region
            textureRegion.getTexture().dispose();
        }
    }
    public TextureRegion getCurrentAppearance() {
        return textureRegion;
    }

}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Exit.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents the exit point in the game.
 */
public class Exit extends Object implements Drawable {
    /** A flag indicating whether the exit has been unlocked (all enemies defeated). */
    private boolean unlocked;

    /** A flag indicating whether the exit is revealed after the wall is destroyed. */
    private boolean revealed;

    /** The wall above the exit (a destructible wall). */
    private WallPath wallAboveExit;

    /**
     * Constructs an Exit object with the specified position, dimensions, animation, and wall above it.
     *
     * @param x           The x-coordinate of the exit.
     * @param y           The y-coordinate of the exit.
     * @param textureRegion  The animation representing the exit's appearance.
     * @param wallAboveExit  The wall above the exit that must be destroyed to reveal the exit.
     */
    public Exit(float x, float y, TextureRegion textureRegion, WallPath wallAboveExit) {
        super(x, y, null);
        this.textureRegion = textureRegion; // Set the visual representation of the entrance.
        this.width = 64; // Default width
        this.height = 64; // Default height
        this.wallAboveExit = wallAboveExit;
        this.unlocked = false;
        this.revealed = false;
    }

    /**
     * Unlocks the exit after all enemies are defeated in the maze.
     */
    public void unlockExit() {
        this.unlocked = true;
    }

    /**
     * Reveals the exit by destroying the wall above it.
     */
    public void revealExit() {
        if (wallAboveExit != null && wallAboveExit.isDestroyed()) {
            this.revealed = true;
        }
    }

    /**
     * Checks if the exit is accessible (unlocked and revealed).
     *
     * @return True if the exit is unlocked and revealed, false otherwise.
     */
    public boolean isAccessible() {
        return unlocked && revealed;
    }

    /**
     * Updates the exit based on the elapsed time since the last update.
     * This method also checks if the wall above it is destroyed and updates the revealed status.
     *
     * @param delta  The time elapsed since the last update.
     */
    @Override
    public void update(float delta) {
        super.update(delta);
        // Check if the exit should be revealed after the wall is destroyed.
        revealExit();
    }

    /**
     * Renders the exit using the specified SpriteBatch.
     * If the exit is revealed, the exit will be drawn.
     * If not, the exit will remain hidden beneath the destructible wall.
     *
     * @param spriteBatch  The SpriteBatch used for rendering.
     */
    @Override
    public void draw(SpriteBatch spriteBatch, float x, float y, float delta, float width, float height) {
        if (revealed && isAccessible()) {
            // Draw the exit only if it's revealed and accessible
            super.draw(spriteBatch, x, y, delta, width, height);
        }
    }

    // Getters and setters
    public boolean isUnlocked() {
        return unlocked;
    }

    public boolean isRevealed() {
        return revealed;
    }

    public WallPath getWallAboveExit() {
        return wallAboveExit;
    }

    public void setWallAboveExit(WallPath wallAboveExit) {
        this.wallAboveExit = wallAboveExit;
    }
    @Override
    public TextureRegion getCurrentAppearance() {
        // just return this.textureRegion
        return textureRegion;
    }

    @Override
    public float getX() {
        return x;  // ‘x’ is inherited from parent
    }

    @Override
    public float getY() {
        return y;
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/GameScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.ScreenUtils;
import de.tum.cit.ase.bomberquest.BomberQuestGame;
import de.tum.cit.ase.bomberquest.map.Enemy;
import de.tum.cit.ase.bomberquest.map.Flowers;
import de.tum.cit.ase.bomberquest.map.Player;
import de.tum.cit.ase.bomberquest.map.PowerUp;
import de.tum.cit.ase.bomberquest.map.WallPath;
import de.tum.cit.ase.bomberquest.texture.Drawable;
import de.tum.cit.ase.bomberquest.map.GameMap;

/**
 * The GameScreen class is responsible for rendering the gameplay screen.
 * It handles the game logic and rendering of the game elements.
 */
public class GameScreen implements Screen {
    
    /**
     * The size of a grid cell in pixels.
     * This allows us to think of coordinates in terms of square grid tiles
     * (e.g. x=1, y=1 is the bottom left corner of the map)
     * rather than absolute pixel coordinates.
     */
    public static final int TILE_SIZE_PX =16;
    
    /**
     * The scale of the game.
     * This is used to make everything in the game look bigger or smaller.
     */
    public static final int SCALE = 2;

    private final BomberQuestGame game;
    private final SpriteBatch spriteBatch;
    private final GameMap map;
    private final Hud hud;
    private final OrthographicCamera mapCamera;


    /**
     * Constructor for GameScreen. Sets up the camera and font.
     *
     * @param game The main game class, used to access global resources and methods.
     */
    public GameScreen(BomberQuestGame game) {
        this.game = game;
        this.spriteBatch = game.getSpriteBatch();
        this.map = game.getMap();
        this.hud = new Hud(spriteBatch, game.getSkin().getFont("font"));
        // Create and configure the camera for the game view
        this.mapCamera = new OrthographicCamera();
        this.mapCamera.setToOrtho(false);

    }
    
    /**
     * The render method is called every frame to render the game.
     * @param deltaTime The time in seconds since the last render.
     */
    @Override
    public void render(float deltaTime) {
        // Check for escape key press to go back to the menu
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            game.goToMenu();
        }
        
        // Clear the previous frame from the screen, or else the picture smears
        ScreenUtils.clear(Color.WHITE);
        
        // Cap frame time to 250ms to prevent spiral of death
        float frameTime = Math.min(deltaTime, 0.250f);
        
        // Update the map state
        map.tick(frameTime);
        
        // Update the camera
        updateCamera();
        
        // Render the map on the screen
        renderMap();
        
        // Render the HUD on the screen
        hud.render();
    }


    /**
     * Updates the camera to match the current state of the game.
     * Currently, this just centers the camera at the origin.
     */
    private void updateCamera() {
        mapCamera.setToOrtho(false);
        mapCamera.position.x = 19.5f * TILE_SIZE_PX * SCALE;
        mapCamera.position.y = 11.5f * TILE_SIZE_PX * SCALE;
        mapCamera.update();
    }
    
    private void renderMap() {
        // This configures the spriteBatch to use the camera's perspective when rendering
        spriteBatch.setProjectionMatrix(mapCamera.combined);

        // Start drawing
        spriteBatch.begin();


    if (map.getChest() != null) {
        draw(spriteBatch, map.getChest());
    }

    // Player should never be null if you instantiate it, but just in case:
    if (map.getPlayer() != null) {
        draw(spriteBatch, map.getPlayer());
    }

    // For walls, skip null entries
    for (WallPath wall : map.getWalls()) {
        if (wall != null) {
            draw(spriteBatch, wall);
        }
    }

    if (map.getEntrance() != null) {
        draw(spriteBatch, map.getEntrance());
    }
    for (Enemy e : map.getEnemies()) {
        draw(spriteBatch, e);
    }
    for (PowerUp p : map.getPowerUps()) {
        draw(spriteBatch, p);
    }

    draw(spriteBatch, map.getExit());

    // Finish drawing, i.e. send the drawn items to the graphics card
    spriteBatch.end();
    }
    /**
     * Draws this object on the screen.
     * The texture will be scaled by the game scale and the tile size.
     * This should only be called between spriteBatch.begin() and spriteBatch.end(), e.g. in the renderMap() method.
     * @param spriteBatch The SpriteBatch to draw with.
     */
    private static void draw(SpriteBatch spriteBatch, Drawable drawable) {
        if (drawable instanceof WallPath wall && wall.isDestroyed()) {
            return; // Skip drawing destroyed walls
        }
        TextureRegion texture = drawable.getCurrentAppearance();

        if (texture == null) {
            System.out.println("DEBUG: getCurrentAppearance() is null for " + drawable.getClass().getSimpleName()
                + " => x=" + drawable.getX() + " y=" + drawable.getY());
            return;  // skip drawing, avoid NPE
        }

        float x, y;
        if (drawable instanceof Player) {
            Player player = (Player) drawable;
            x = player.getX() * TILE_SIZE_PX * SCALE - 0.3f * TILE_SIZE_PX * SCALE; // Adjust for radius
            y = player.getY() * TILE_SIZE_PX * SCALE - 0.3f * TILE_SIZE_PX * SCALE;
        } else {
            x = drawable.getX() * TILE_SIZE_PX * SCALE;
            y = drawable.getY() * TILE_SIZE_PX * SCALE;
        }

        float width = texture.getRegionWidth() * SCALE;
        float height = texture.getRegionHeight() * SCALE;
        spriteBatch.draw(texture, x, y, width, height);
    }
    
    /**
     * Called when the window is resized.
     * This is where the camera is updated to match the new window size.
     * @param width The new window width.
     * @param height The new window height.
     */
    @Override
    public void resize(int width, int height) {
        mapCamera.setToOrtho(false);
        hud.resize(width, height);
    }

    // Unused methods from the Screen interface
    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void show() {

    }

    @Override
    public void hide() {
    }

    @Override
    public void dispose() {
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/MenuScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import com.badlogic.gdx.utils.viewport.Viewport;
import de.tum.cit.ase.bomberquest.BomberQuestGame;

/**
 * The MenuScreen class is responsible for displaying the main menu of the game.
 * It extends the LibGDX Screen class and sets up the UI components for the menu.
 */
public class MenuScreen implements Screen {

    private final Stage stage;

    /**
     * Constructor for MenuScreen. Sets up the camera, viewport, stage, and UI elements.
     *
     * @param game The main game class, used to access global resources and methods.
     */
    public MenuScreen(BomberQuestGame game) {
        var camera = new OrthographicCamera();
        camera.zoom = 1.5f; // Set camera zoom for a closer view

        Viewport viewport = new ScreenViewport(camera); // Create a viewport with the camera
        stage = new Stage(viewport, game.getSpriteBatch()); // Create a stage for UI elements

        Table table = new Table(); // Create a table for layout
        table.setFillParent(true); // Make the table fill the stage
        stage.addActor(table); // Add the table to the stage

        // Add a label as a title
        table.add(new Label("Hello World from the Menu!", game.getSkin(), "title")).padBottom(80).row();

        // Create and add a button to go to the game screen
        TextButton goToGameButton = new TextButton("Go To Game", game.getSkin());
        table.add(goToGameButton).width(300).row();
        goToGameButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.goToGame(); // Change to the game screen when button is pressed
            }
        });
    }

    /**
     * The render method is called every frame to render the menu screen.
     * It clears the screen and draws the stage.
     * @param deltaTime The time in seconds since the last render.
     */
    @Override
    public void render(float deltaTime) {
        float frameTime = Math.min(deltaTime, 0.250f); // Cap frame time to 250ms to prevent spiral of death        ScreenUtils.clear(Color.BLACK);
        ScreenUtils.clear(Color.BLACK); // Clear the screen
        stage.act(frameTime); // Update the stage
        stage.draw(); // Draw the stage
    }

    /**
     * Resize the stage when the screen is resized.
     * @param width The new width of the screen.
     * @param height The new height of the screen.
     */
    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true); // Update the stage viewport on resize
    }

    @Override
    public void dispose() {
        // Dispose of the stage when screen is disposed
        stage.dispose();
    }

    @Override
    public void show() {
        // Set the input processor so the stage can receive input events
        Gdx.input.setInputProcessor(stage);
    }

    // The following methods are part of the Screen interface but are not used in this screen.
    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/Hud.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;

/**
 * A Heads-Up Display (HUD) that displays information on the screen.
 * It uses a separate camera so that it is always fixed on the screen.
 */
public class Hud {
    
    /** The SpriteBatch used to draw the HUD. This is the same as the one used in the GameScreen. */
    private final SpriteBatch spriteBatch;
    /** The font used to draw text on the screen. */
    private final BitmapFont font;
    /** The camera used to render the HUD. */
    private final OrthographicCamera camera;
    
    public Hud(SpriteBatch spriteBatch, BitmapFont font) {
        this.spriteBatch = spriteBatch;
        this.font = font;
        this.camera = new OrthographicCamera();
    }
    
    /**
     * Renders the HUD on the screen.
     * This uses a different OrthographicCamera so that the HUD is always fixed on the screen.
     */
    public void render() {
        // Render from the camera's perspective
        spriteBatch.setProjectionMatrix(camera.combined);
        // Start drawing
        spriteBatch.begin();
        // Draw the HUD elements
        font.draw(spriteBatch, "Press Esc to Pause!", 10, Gdx.graphics.getHeight() - 10);
        // Finish drawing
        spriteBatch.end();
    }
    
    /**
     * Resizes the HUD when the screen size changes.
     * This is called when the window is resized.
     * @param width The new width of the screen.
     * @param height The new height of the screen.
     */
    public void resize(int width, int height) {
        camera.setToOrtho(false, width, height);
    }
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/VictoryScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import de.tum.cit.ase.bomberquest.BomberQuestGame;

/**
 * The VictoryScreen class represents the screen displayed when the player achieves victory.
 * It provides options to return to the main menu.
 */
public class VictoryScreen implements Screen {

    private final BomberQuestGame game;
    private final Screen previousScreen;
    private Stage stage;
    private final Skin skin;

    /**
     * Creates a new VictoryScreen.
     *
     * @param game           The main game instance
     * @param previousScreen The previous screen to potentially return to
     * @param skin          The skin used for UI elements
     */
    public VictoryScreen(BomberQuestGame game, Screen previousScreen, Skin skin) {
        this.game = game;
        this.previousScreen = previousScreen;
        this.skin = skin;
    }

    @Override
    public void show() {
        stage = new Stage();
        Table table = new Table();
        table.setFillParent(true);
        stage.addActor(table);
        Gdx.input.setInputProcessor(stage);

        // Create victory label with animation
        Label victoryLabel = new Label("Victory!", skin, "title");
        table.add(victoryLabel).padBottom(80).row();

        // Add blinking animation to the victory label
        victoryLabel.addAction(Actions.forever(Actions.sequence(
                Actions.fadeIn(0.7f),
                Actions.fadeOut(0.7f)
        )));

        // Create and add the back to menu button
        TextButton backToMenuButton = new TextButton("Return to Menu", skin);
        table.add(backToMenuButton).padBottom(20).row();

        // Add click listener for the menu button
        backToMenuButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                game.goToMenu();
            }
        });

        // Optional: Add more stats or information about the victory
        Label statsLabel = new Label("Congratulations! You've completed the level!", skin);
        table.add(statsLabel).padTop(20).row();
    }

    @Override
    public void render(float delta) {
        // Clear the screen
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Update and draw the stage
        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
    }

    @Override
    public void dispose() {
        if (stage != null) {
            stage.dispose();
        }
    }
    //test
    //sync
}

--- File: core/src/de/tum/cit/ase/bomberquest/screen/GameOverScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

public class GameOverScreen {
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Drawable.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Represents something that can be drawn on the screen.
 * NOTE: The position returned by {@link #getX()} and {@link #getY()} is the
 * position of the BOTTOM LEFT CORNER of the texture in the game.
 */
public interface Drawable {
    
    /**
     * Gets the current appearance of the Drawable.
     * This can change over time.
     * @return The current appearance as a {@link TextureRegion}.
     */
    TextureRegion getCurrentAppearance();
    
    /**
     * Gets the X coordinate of the drawable in the game world grid.
     * Note that this is a TILE coordinate, not a pixel coordinate.
     * It must be multiplied by {@link de.tum.cit.ase.bomberquest.screen.GameScreen#TILE_SIZE_PX}
     * and {@link de.tum.cit.ase.bomberquest.screen.GameScreen#SCALE} to get the pixel coordinate.
     * @return The X coordinate of the drawable.
     */
    float getX();
    
    /**
     * Gets the Y coordinate of the drawable in the game world grid.
     * Note that this is a TILE coordinate, not a pixel coordinate.
     * It must be multiplied by {@link de.tum.cit.ase.bomberquest.screen.GameScreen#TILE_SIZE_PX}
     * and {@link de.tum.cit.ase.bomberquest.screen.GameScreen#SCALE} to get the pixel coordinate.
     * @return The Y coordinate of the drawable.
     */
    float getY();
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Textures.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Contains all texture constants used in the game.
 * It is good practice to keep all textures and animations in constants to avoid loading them multiple times.
 * These can be referenced anywhere they are needed.
 */
public class Textures {
    
    public static final TextureRegion FLOWERS = SpriteSheet.BASIC_TILES.at(2, 5);
    public static final TextureRegion DEST_WALL = SpriteSheet.BASIC_TILES.at(1,4 );
    public static final TextureRegion INDEST_WALL = SpriteSheet.BASIC_TILES.at(1,6 );
    public static final TextureRegion CHEST = SpriteSheet.BASIC_TILES.at(5, 5);
    public static final TextureRegion ENTRANCE = SpriteSheet.BASIC_TILES.at(4, 6);
    public static final TextureRegion EXIT = SpriteSheet.BASIC_TILES.at(2,4);
    public static final TextureRegion POWER_UP = SpriteSheet.BASIC_TILES.at(3,3);
    public static final TextureRegion ENEMY = SpriteSheet.CHARACTER.at(3,1);
    
}



--- File: core/src/de/tum/cit/ase/bomberquest/texture/SpriteSheet.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

import de.tum.cit.ase.bomberquest.map.PowerUp;

/**
 * Enumerates all spritesheets used in the game and provides helper methods for grabbing texture regions from them.
 * It is assumed that every spritesheet has some standard grid size which can be used for easier coordinate specification.
 * See the assets/texture folder for the actual texture files (plus some more samples which are not enumerated here).
 * Feel free to add your own spritesheets and use them in the game!
 *
 * @see Texture a whole image
 * @see TextureRegion a part of an image
 */
public enum SpriteSheet {
    
    /** The character spritesheet, which has a grid size of 16x32. */
    CHARACTER("character.png", 16, 20),
    /** The basic tiles spritesheet, which has a grid size of 16x16. */
    BASIC_TILES("basictiles.png", 16, 16),

    POWER_UP("powerup.png", 16, 16);
    
private final Texture spritesheet;
    private final int width;
    private final int height;
    
    /**
     * Constructor for each variant of this enum.
     * Every SpriteSheet has a corresponding file, width, and height.
     * @param filename the filename of the spritesheet
     * @param width the width of a single grid cell
     * @param height the height of a single grid cell
     */
    SpriteSheet(String filename, int width, int height) {
        this.spritesheet = new Texture(Gdx.files.internal("texture/" + filename));
        this.width = width;
        this.height = height;
    }
    
    /**
     * Returns the TextureRegion at the specified row and column (1-based coordinates)
     * according to the grid specified by {@code this.width} and {@code this.height}.
     * This method assumes the size of the texture to be a single grid cell.
     * Keep in mind that since spritesheet textures typically start in the top-left corner,
     * the row index starts at 1 at the top and the column index starts at 1 on the left.
     *
     * @param row the row of the texture to fetch, starting from 1 at the TOP of the spritesheet
     * @param column the column of the texture to fetch, starting from 1 on the LEFT of the spritesheet
     * @return the texture
     */
    public TextureRegion at(int row, int column) {
        return new TextureRegion(
                spritesheet,
                (column - 1) * this.width,
                (row - 1) * this.height,
                this.width,
                this.height
        );
    }
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Animations.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Contains all animation constants used in the game.
 * It is good practice to keep all textures and animations in constants to avoid loading them multiple times.
 * These can be referenced anywhere they are needed.
 */
public class Animations {
    
    /**
     * The animation for the character walking down.
     */
    public static final Animation<TextureRegion> CHARACTER_WALK_DOWN = new Animation<>(0.1f,
            SpriteSheet.CHARACTER.at(1, 1),
            SpriteSheet.CHARACTER.at(1, 2),
            SpriteSheet.CHARACTER.at(1, 3),
            SpriteSheet.CHARACTER.at(1, 4)
    );
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/entities/Bomb.java ---

package de.tum.cit.ase.bomberquest.entities;

public class Bomb {
}


--- File: desktop/build.gradle ---

java {
    sourceCompatibility = JavaVersion.VERSION_17
}
sourceSets.main.java.srcDirs = [ "src/" ]
sourceSets.main.resources.srcDirs = ["../assets"]

project.ext.mainClassName = "de.tum.cit.ase.bomberquest.DesktopLauncher"
project.ext.assetsDir = new File("../assets")

import org.gradle.internal.os.OperatingSystem

tasks.register('run', JavaExec) {
    dependsOn classes
    mainClass = project.mainClassName
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = file("../")
    ignoreExitValue = true

    if (OperatingSystem.current() == OperatingSystem.MAC_OS) {
        // Required to run on macOS
        jvmArgs += "-XstartOnFirstThread"
    }
}

tasks.register('debug', JavaExec) {
    dependsOn classes
    mainClass = project.mainClassName
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = file("../")
    ignoreExitValue = true
    debug = true
}

tasks.register('dist', Jar) {
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
    manifest {
        attributes 'Main-Class': project.mainClassName
    }
    dependsOn configurations.runtimeClasspath
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    with jar
}


dist.dependsOn classes

eclipse.project.name = appName + "-desktop"


--- File: desktop/bin/main/skin/craftacular/craftacular-ui.json ---

{
com.badlogic.gdx.graphics.g2d.BitmapFont: {
	bold: {
		file: font-bold-export.fnt
	}
	font: {
		file: font-export.fnt
	}
	title: {
		file: font-title-export.fnt
	}
}
com.badlogic.gdx.graphics.Color: {
	gray: {
		r: 0.55
		g: 0.55
		b: 0.55
		a: 1
	}
	green: {
		r: 0.03529522
		g: 0.77666664
		b: 0
		a: 1
	}
	white: {
		r: 1
		g: 1
		b: 1
		a: 1
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable: {
	gray: {
		name: white
		color: {
			r: 0.73666674
			g: 0.73666674
			b: 0.73666674
			a: 1
		}
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle: {
	default: {
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle: {
	default: {
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle: {
	default: {
		font: font
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle: {
	default: {
		font: font
	}
	dim: {
		font: font
		fontColor: gray
	}
	bold: {
		font: bold
		background: underline
	}
	title: {
		font: title
	}
	xp: {
		font: bold
		fontColor: green
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle: {
	default-horizontal: {
		background: slider
		knobBefore: slider-knob
	}
	default-vertical: {
		background: slider
		knob: slider-knob
	}
	hunger: {
		background: meat-bg
		knobAfter: meat
	}
	health: {
		background: heart-bg
		knobBefore: heart
	}
	xp: {
		background: xp-bg
		knobBefore: xp
	}
	armor: {
		background: armor-bg
		knobBefore: armor
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle: {
	default: {
		background: scroll-bg
		hScroll: scroll-horizontal
		hScrollKnob: scroll-knob-horizontal
		vScroll: scroll-vertical
		vScrollKnob: scroll-knob-vertical
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle: {
	default-horizontal: {
		background: slider
		knob: slider-knob
	}
	default-vertical: {
		background: slider
		knob: slider-knob
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle: {
	default: {
		font: font
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle: {
	default: {
		font: font
		fontColor: white
		background: text-field
		cursor: cursor
		selection: gray
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextTooltip$TextTooltipStyle: {
	default: {
		label: default
		background: tooltip
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle: {
	default: {
		background: window
		titleFont: font
	}
}
}

--- File: desktop/build/resources/main/skin/craftacular/craftacular-ui.json ---

{
com.badlogic.gdx.graphics.g2d.BitmapFont: {
	bold: {
		file: font-bold-export.fnt
	}
	font: {
		file: font-export.fnt
	}
	title: {
		file: font-title-export.fnt
	}
}
com.badlogic.gdx.graphics.Color: {
	gray: {
		r: 0.55
		g: 0.55
		b: 0.55
		a: 1
	}
	green: {
		r: 0.03529522
		g: 0.77666664
		b: 0
		a: 1
	}
	white: {
		r: 1
		g: 1
		b: 1
		a: 1
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable: {
	gray: {
		name: white
		color: {
			r: 0.73666674
			g: 0.73666674
			b: 0.73666674
			a: 1
		}
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle: {
	default: {
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle: {
	default: {
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle: {
	default: {
		font: font
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle: {
	default: {
		font: font
	}
	dim: {
		font: font
		fontColor: gray
	}
	bold: {
		font: bold
		background: underline
	}
	title: {
		font: title
	}
	xp: {
		font: bold
		fontColor: green
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle: {
	default-horizontal: {
		background: slider
		knobBefore: slider-knob
	}
	default-vertical: {
		background: slider
		knob: slider-knob
	}
	hunger: {
		background: meat-bg
		knobAfter: meat
	}
	health: {
		background: heart-bg
		knobBefore: heart
	}
	xp: {
		background: xp-bg
		knobBefore: xp
	}
	armor: {
		background: armor-bg
		knobBefore: armor
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle: {
	default: {
		background: scroll-bg
		hScroll: scroll-horizontal
		hScrollKnob: scroll-knob-horizontal
		vScroll: scroll-vertical
		vScrollKnob: scroll-knob-vertical
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle: {
	default-horizontal: {
		background: slider
		knob: slider-knob
	}
	default-vertical: {
		background: slider
		knob: slider-knob
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle: {
	default: {
		font: font
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle: {
	default: {
		font: font
		fontColor: white
		background: text-field
		cursor: cursor
		selection: gray
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextTooltip$TextTooltipStyle: {
	default: {
		label: default
		background: tooltip
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle: {
	default: {
		background: window
		titleFont: font
	}
}
}

--- File: desktop/src/de/tum/cit/ase/bomberquest/DesktopLauncher.java ---

package de.tum.cit.ase.bomberquest;

import com.badlogic.gdx.Graphics;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration;
import games.spooky.gdx.nativefilechooser.desktop.DesktopFileChooser;



/**
 * The DesktopLauncher class is the entry point for the desktop version of the Bomber Quest game.
 * It sets up the game window and launches the game using LibGDX framework.
 */
public class DesktopLauncher {
	/**
	 * The main method sets up the configuration for the game window and starts the application.
	 *
	 * @param arg Command line arguments (not used in this application)
	 */
	public static void main(String[] arg) {
		// Configuration for the game window
		Lwjgl3ApplicationConfiguration config = new Lwjgl3ApplicationConfiguration();
		config.setTitle("Bomber Quest"); // Set the window title

		// Get the display mode of the current monitor
		Graphics.DisplayMode displayMode = Lwjgl3ApplicationConfiguration.getDisplayMode();
		// Set the window size to 80% of the screen width and height
		config.setWindowedMode(
				Math.round(0.8f * displayMode.width),
				Math.round(0.8f * displayMode.height)
		);
		config.useVsync(true); // Enable vertical sync
		config.setForegroundFPS(60); // Set the foreground frames per second

		System.out.println("Working directory: " + System.getProperty("user.dir"));

		// Launch the game
		new Lwjgl3Application(new BomberQuestGame(new DesktopFileChooser()), config);
	}
}


--- File: assets/skin/craftacular/craftacular-ui.json ---

{
com.badlogic.gdx.graphics.g2d.BitmapFont: {
	bold: {
		file: font-bold-export.fnt
	}
	font: {
		file: font-export.fnt
	}
	title: {
		file: font-title-export.fnt
	}
}
com.badlogic.gdx.graphics.Color: {
	gray: {
		r: 0.55
		g: 0.55
		b: 0.55
		a: 1
	}
	green: {
		r: 0.03529522
		g: 0.77666664
		b: 0
		a: 1
	}
	white: {
		r: 1
		g: 1
		b: 1
		a: 1
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable: {
	gray: {
		name: white
		color: {
			r: 0.73666674
			g: 0.73666674
			b: 0.73666674
			a: 1
		}
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle: {
	default: {
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle: {
	default: {
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle: {
	default: {
		font: font
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle: {
	default: {
		font: font
	}
	dim: {
		font: font
		fontColor: gray
	}
	bold: {
		font: bold
		background: underline
	}
	title: {
		font: title
	}
	xp: {
		font: bold
		fontColor: green
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle: {
	default-horizontal: {
		background: slider
		knobBefore: slider-knob
	}
	default-vertical: {
		background: slider
		knob: slider-knob
	}
	hunger: {
		background: meat-bg
		knobAfter: meat
	}
	health: {
		background: heart-bg
		knobBefore: heart
	}
	xp: {
		background: xp-bg
		knobBefore: xp
	}
	armor: {
		background: armor-bg
		knobBefore: armor
	}
}
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle: {
	default: {
		background: scroll-bg
		hScroll: scroll-horizontal
		hScrollKnob: scroll-knob-horizontal
		vScroll: scroll-vertical
		vScrollKnob: scroll-knob-vertical
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle: {
	default-horizontal: {
		background: slider
		knob: slider-knob
	}
	default-vertical: {
		background: slider
		knob: slider-knob
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle: {
	default: {
		font: font
		up: button
		over: button-hover
		disabled: button-disabled
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle: {
	default: {
		font: font
		fontColor: white
		background: text-field
		cursor: cursor
		selection: gray
	}
}
com.badlogic.gdx.scenes.scene2d.ui.TextTooltip$TextTooltipStyle: {
	default: {
		label: default
		background: tooltip
	}
}
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle: {
	default: {
		background: window
		titleFont: font
	}
}
}