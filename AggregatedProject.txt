

--- File: build.gradle ---

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        gradlePluginPortal()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        google()
    }
    dependencies {

    }
}

allprojects {
    apply plugin: "eclipse"

    version = '1.0'
    ext {
        appName = "Bomber Quest"
        gdxVersion = '1.13.0'
        roboVMVersion = '2.3.20'
        box2DLightsVersion = '1.5'
        ashleyVersion = '1.7.4'
        aiVersion = '1.8.2'
        gdxControllersVersion = '2.2.1'
        gdxNativefilechooserVersion = '2.3.0'
    }

    repositories {
        mavenLocal()
        mavenCentral()
        google()
        gradlePluginPortal()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
        maven { url "https://jitpack.io" }
    }

    tasks.withType(JavaCompile).configureEach {
        javaCompiler = javaToolchains.compilerFor {
            languageVersion = JavaLanguageVersion.of(17)
        }
    }
}

project(":desktop") {
    apply plugin: "java-library"

    dependencies {
        implementation project(":core")
        api "com.badlogicgames.gdx:gdx-backend-lwjgl3:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
        api "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-desktop"
        implementation "games.spooky.gdx:gdx-nativefilechooser-desktop-lwjgl:$gdxNativefilechooserVersion"
        api "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-desktop"
    }
}

project(":core") {
    apply plugin: "java-library"

    dependencies {
        api "com.badlogicgames.gdx:gdx:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
        implementation "games.spooky.gdx:gdx-nativefilechooser:$gdxNativefilechooserVersion"
        api "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
    }
}


--- File: settings.gradle ---

include 'desktop', 'core'

--- File: core/build.gradle ---

java {
    sourceCompatibility = JavaVersion.VERSION_17
}
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

sourceSets.main.java.srcDirs = [ "src/" ]

eclipse.project.name = appName + "-core"


--- File: core/src/de/tum/cit/ase/bomberquest/BomberQuestGame.java ---

package de.tum.cit.ase.bomberquest;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import de.tum.cit.ase.bomberquest.audio.MusicTrack;
import de.tum.cit.ase.bomberquest.screen.GameScreen;
import de.tum.cit.ase.bomberquest.screen.MenuScreen;
import games.spooky.gdx.nativefilechooser.NativeFileChooser;

/**
 * The BomberQuestGame class represents the core of the Bomber Quest game.
 * It manages the screens and global resources like SpriteBatch and Skin.
 */
public class BomberQuestGame extends Game {

    private SpriteBatch spriteBatch;
    private Skin skin;
    private final NativeFileChooser fileChooser;

    public BomberQuestGame(NativeFileChooser fileChooser) {
        this.fileChooser = fileChooser;
    }

    @Override
    public void create() {
        spriteBatch = new SpriteBatch();
        skin = new Skin(Gdx.files.internal("skin/craftacular/craftacular-ui.json"));

        // Play background music
        MusicTrack.BACKGROUND.play();

        // Start on menu
        goToMenu();
    }

    public void goToMenu() {
        setScreen(new MenuScreen(this));
    }

    public void goToGame() {
        setScreen(new GameScreen(this, "maps/map.properties")); 
        // We pass the path to the map file. 
        // 'GameScreen' will parse it into a TileMap, create all objects, etc.
    }

    public SpriteBatch getSpriteBatch() {
        return spriteBatch;
    }

    public Skin getSkin() {
        return skin;
    }

    @Override
    public void dispose() {
        super.dispose();
        spriteBatch.dispose();
        skin.dispose();
    }

    @Override
    public void setScreen(Screen screen) {
        Screen previous = getScreen();
        super.setScreen(screen);
        // If we are switching away from a screen that is *not* the GameScreen, or
        // if we truly want to discard it, we can dispose. Otherwise, keep it.
        if (previous != null
            && !(previous instanceof GameScreen)) { 
            previous.dispose();
        }
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/audio/MusicTrack.java ---

package de.tum.cit.ase.bomberquest.audio;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;

/**
 * This enum is used to manage the music tracks in the game.
 * Currently, only one track is used, but this could be extended to include multiple tracks.
 * Using an enum for this purpose is a good practice, as it allows for easy management of the music tracks
 * and prevents the same track from being loaded into memory multiple times.
 * See the assets/audio folder for the actual music files.
 * Feel free to add your own music tracks and use them in the game!
 */
public enum MusicTrack {
    
    BACKGROUND("background.mp3", 0.2f),
    MENU("menu.wav", 0.2f);
    
    /** The music file owned by this variant. */
    private final Music music;
    
    MusicTrack(String fileName, float volume) {
        this.music = Gdx.audio.newMusic(Gdx.files.internal("audio/" + fileName));
        this.music.setLooping(true);
        this.music.setVolume(volume);
    }
    
    /**
     * Play this music track.
     * This will not stop other music from playing - if you add more tracks, you will have to handle that yourself.
     */
    public void play() {
        this.music.play();
    }
    /** Stop playback of this music track. */
    public void stop() {
        this.music.stop();
    }

    /** Pause playback of this music track. */
    public void pause() {
        this.music.pause();
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Bomb.java ---

package de.tum.cit.ase.bomberquest.map;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.MathUtils;

import de.tum.cit.ase.bomberquest.audio.SoundEffects;
import de.tum.cit.ase.bomberquest.texture.Animations;

/**
 * A tile-based bomb with a 3s fuse, calls back into GameMapLogic for explosion logic.
 */
public class Bomb {

    private final int bombX, bombY;
    private final int blastRadius;
    private final long placeTime;
    private boolean exploded = false;

    private float fuseTime = 3f;  // how many seconds until explosion
    private float fuseTimer = 0f;
    private float blastDuration = 0.28f; // total explosion frames time
    private float explosionTimer = 0f;

    private float animTime = 0f; 
    private final List<ExplosionTile> affectedTiles = new ArrayList<>();

    private static final float FUSE_TIME_SECONDS = 3f;

    private final GameMapLogic logic;

    private boolean done = false; // means "completely finished, remove from list"

    public boolean isDone() {
    return done;
}

    public Bomb(int x, int y, int radius, GameMapLogic logic) {
        this.bombX = x;
        this.bombY = y;
        this.blastRadius = radius;
        this.logic = logic;
        this.placeTime = System.currentTimeMillis();
    }

    public void update(float delta) {
        if (!exploded) {
            // Fuse phase: accumulate time
            animTime += delta;
            fuseTimer += delta;
            if (fuseTimer >= fuseTime) {
                // Bomb goes off
                exploded = true;
                explosionTimer = 0f;
                explode();
            }
        } else {
            // Explosion phase: track time
            explosionTimer += delta;
            if (explosionTimer > blastDuration) {
                // Explosion animation ended => remove bomb from map
                done = true;
            }
        }
    }

    private void explode() {
        exploded = true;
        // damage center tile
        logic.handleExplosionTile(bombX, bombY);

        // center
        for (int i = 1; i <= blastRadius; i++) {
            int tx = bombX;
            int ty = bombY;
            boolean blocked = handleExplosionTile(tx, ty);
            if (!blocked) {
                // We managed to hit tile (tx, ty)
            } else {
                break; // wall found, stop
            }
        }

        // up
        for (int i = 1; i <= blastRadius; i++) {
            int tx = bombX;
            int ty = bombY + i;
            boolean blocked = handleExplosionTile(tx, ty);
            if (!blocked) {
                // We managed to hit tile (tx, ty)
            } else {
                break; // wall found, stop
            }
        }

        // down
        for (int i = 1; i <= blastRadius; i++) {
            int tx = bombX;
            int ty = bombY - i;
            boolean blocked = handleExplosionTile(tx, ty);
            if (!blocked) {
                // We managed to hit tile (tx, ty)
            } else {
                break; // wall found, stop
            }
        }

        // right
        for (int i = 1; i <= blastRadius; i++) {
            int tx = bombX + i;
            int ty = bombY;
            boolean blocked = handleExplosionTile(tx, ty);
            if (!blocked) {
                // We managed to hit tile (tx, ty)
            } else {
                break; // wall found, stop
            }
        }

        // left
        for (int i = 1; i <= blastRadius; i++) {
            int tx = bombX - i;
            int ty = bombY;
            boolean blocked = handleExplosionTile(tx, ty);
            if (!blocked) {
                // We managed to hit tile (tx, ty)
            } else {
                break; // wall found, stop
            }
        }
        // 2) play sound
        SoundEffects.BOMB_EXPLODE.play();

    }

        // A wrapper to call logic.handleExplosionTile(...) AND store the tile if not blocked
    private boolean handleExplosionTile(int x, int y) {
        boolean blocked = logic.handleExplosionTile(x, y);
        // If it's not blocked, that tile is part of the blast area
        // (The tile might be destructible or free. If destructible, we still show the flame)
        if (!blocked) {
            affectedTiles.add(new ExplosionTile(x, y));
        }
        return blocked;
    }

    public boolean isExploded() {
        return exploded;
    }

    public void renderFuse(SpriteBatch batch, float tileSize) {
        if (!exploded) {
            // Draw the fuse animation
            float px = bombX * tileSize;
            float py = bombY * tileSize;
            TextureRegion fuseFrame = Animations.BOMB_FUSE.getKeyFrame(animTime, true);
            batch.draw(fuseFrame, px, py);
        }
    }

    public void renderExplosion(ShapeRenderer shapeRenderer, float tileSize) {
        if (!exploded || done) return;

        float progress = explosionTimer / blastDuration; // 0..1
    
        for (ExplosionTile tile : affectedTiles) {
            // Flicker alpha a bit
            float alpha = (1 - progress) * (0.5f + MathUtils.random(0.2f));
    
            // Outer color
            shapeRenderer.setColor(1f, 0.2f, 0f, alpha);
            shapeRenderer.rect(tile.x*tileSize, tile.y*tileSize, tileSize, tileSize);
    
            // Inner color is brighter, smaller
            shapeRenderer.setColor(1f, 0.8f, 0f, alpha + 0.2f);
            float inset = tileSize * 0.90f;
            shapeRenderer.rect(tile.x*tileSize+inset, tile.y*tileSize+inset, tileSize-(inset), tileSize-(inset));
        }
    

    }


    public int getX() {return bombX;}
    public int getY() {return bombY;}
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Enemy.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;

import de.tum.cit.ase.bomberquest.texture.Animations;

/**
 * A tile-based enemy that moves randomly every 1 second
 * and uses direction-based animations.
 */
public class Enemy {

    private enum Direction { UP, DOWN, LEFT, RIGHT }

    private int tileX, tileY;
    private final TileMap tileMap;
    private final GameMapLogic logic;

    // For random movement:
    private float dirTimer = 0f;
    private float dirInterval = 1f;
    private int dx = 0, dy = 0;
    private Direction currentDirection = Direction.DOWN;

    // For animations:
    private float animTime = 0f;

    public Enemy(TileMap tileMap, int startX, int startY, GameMapLogic logic) {
        this.tileMap = tileMap;
        this.tileX = startX;
        this.tileY = startY;
        this.logic = logic;
    }

    public void update(float delta) {
        // Accumulate time for animation:
        animTime += delta;

        // Every 'dirInterval' seconds, pick a new random direction and move 1 tile:
        dirTimer += delta;
        if (dirTimer >= dirInterval) {
            dirTimer = 0f;
            pickRandomDirection();
            tryMove(dx, dy);
        }

        // Check collision with player:
        if (tileX == logic.getPlayer().getTileX() && tileY == logic.getPlayer().getTileY()) {
            logic.killPlayer("Enemy touched you!");
        }
    }

    /**
     * Picks a random direction among (R, L, U, D), 
     * sets dx/dy accordingly, and updates currentDirection
     * so we select the correct animation.
     */
    private void pickRandomDirection() {
        int r = MathUtils.random(3);
        switch(r) {
            case 0:
                dx = 1; dy = 0;
                currentDirection = Direction.RIGHT;
                break;
            case 1:
                dx = -1; dy = 0;
                currentDirection = Direction.LEFT;
                break;
            case 2:
                dx = 0; dy = 1;
                currentDirection = Direction.UP;
                break;
            case 3:
                dx = 0; dy = -1;
                currentDirection = Direction.DOWN;
                break;
        }
    }

    /**
     * Attempt to move one tile in the chosen direction,
     * checking whether the tile is blocked.
     */
    private void tryMove(int dx,int dy) {
        int nx = tileX + dx;
        int ny = tileY + dy;
        if (!tileMap.isBlocked(nx, ny)) {
            tileX = nx;
            tileY = ny;
        }
    }

    /**
     * Renders the enemy by selecting the correct direction-based 
     * animation from Animations.java, then drawing the current frame.
     */
    public void render(SpriteBatch batch, float tileSizePx) {
        float px = tileX * tileSizePx;
        float py = tileY * tileSizePx;

        // Pick the animation for the current direction:
        Animation<TextureRegion> currentAnim;
        switch (currentDirection) {
            case UP:
                currentAnim = Animations.ENEMY_UP;
                break;
            case DOWN:
                currentAnim = Animations.ENEMY_DOWN;
                break;
            case LEFT:
                currentAnim = Animations.ENEMY_LEFT;
                break;
            case RIGHT:
            default:
                currentAnim = Animations.ENEMY_RIGHT;
                break;
        }

        // Get the current frame (looping = true)
        TextureRegion frame = currentAnim.getKeyFrame(animTime, true);
        batch.draw(frame, px, py);
    }

    public int getTileX() { return tileX; }
    public int getTileY() { return tileY; }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Flowers.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import de.tum.cit.ase.bomberquest.texture.Drawable;
import de.tum.cit.ase.bomberquest.texture.Textures;

/**
 * Flowers are a static object without any special properties.
 * They do not have a hitbox, so the player does not collide with them.
 * They are purely decorative and serve as a nice floor decoration.
 */
public class Flowers implements Drawable {
    
    private final int x;
    private final int y;
    
    public Flowers(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public TextureRegion getCurrentAppearance() {
        return Textures.FLOWERS;
    }
    
    @Override
    public float getX() {
        return x;
    }
    
    @Override
    public float getY() {
        return y;
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/map/PowerUp.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

public class PowerUp {

    private final int tileX, tileY;
    private final int powerType; // 5 => concurrency, 6 => blast radius
    private final TextureRegion sprite;

    public PowerUp(int x, int y, int type, TextureRegion sprite) {
        this.tileX = x;
        this.tileY = y;
        this.powerType = type;
        this.sprite = sprite;
    }

    public void render(SpriteBatch batch, float tileSizePx) {
        float px = tileX * tileSizePx;
        float py = tileY * tileSizePx;
        batch.draw(sprite, px, py);
    }

    public int getTileX(){return tileX;}
    public int getTileY(){return tileY;}
    public int getPowerType(){return powerType;}
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/TileMap.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;

import java.util.ArrayList;
import java.util.List;

/**
 * Tile-based map storage. Each (x,y) holds a tile code:
 * 0 => Floor (free)
 * 1 => Indestructible wall
 * 2 => Destructible wall
 * 
 *  We also keep track of:
 *    - the player's spawn (entranceX, entranceY)
 *    - enemies positions
 *    - power-ups positions
 *    - exit position
 */
public class TileMap {

    public static final int FLOOR = 0;
    public static final int WALL_INDESTRUCTIBLE = 1;
    public static final int WALL_DESTRUCTIBLE = 2;

    private final int width;
    private final int height;
    private final int[][] tiles; // tile[y][x]

    // These are read from map file for convenience:
    private int entranceX, entranceY;
    private int exitX, exitY;

    // We’ll store a separate list for enemies, powerUps, etc.
    private final List<EnemySpawn> enemySpawns = new ArrayList<>();
    private final List<PowerUpSpawn> powerUpSpawns = new ArrayList<>();

    /**
     * Creates a tile map with given dimensions (like 40×24).
     */
    public TileMap(int width, int height) {
        this.width = width;
        this.height = height;
        this.tiles = new int[height][width];
        // default everything to floor
        for (int y=0; y<height; y++) {
            for (int x=0; x<width; x++) {
                tiles[y][x] = FLOOR;
            }
        }
    }

    /**
     * Return true if tile is blocked (either indestructible or destructible).
     */
    public boolean isBlocked(int x, int y) {
        if (x<0 || x>=width || y<0 || y>=height) return true; 
        int t = tiles[y][x];
        return (t == WALL_INDESTRUCTIBLE || t == WALL_DESTRUCTIBLE);
    }

    public void setTile(int x, int y, int type) {
        if (x<0||x>=width||y<0||y>=height) return;
        tiles[y][x] = type;
    }

    public int getTile(int x, int y) {
        if (x<0||x>=width||y<0||y>=height) return WALL_INDESTRUCTIBLE;
        return tiles[y][x];
    }

    public int getWidth() { return width; }
    public int getHeight() { return height; }

    public int getEntranceX() { return entranceX; }
    public int getEntranceY() { return entranceY; }
    public int getExitX() { return exitX; }
    public int getExitY() { return exitY; }

    public List<EnemySpawn> getEnemySpawns() { return enemySpawns; }
    public List<PowerUpSpawn> getPowerUpSpawns() { return powerUpSpawns; }

    /**
     * Loads from a properties style file, reading lines like "x,y=type".
     */
    public void loadFromProperties(String path) {
        FileHandle handle = Gdx.files.internal(path);
        String content = handle.readString();
        String[] lines = content.split("\\r?\\n");

        for (String line : lines) {
            line=line.trim();
            if (line.isEmpty() || line.startsWith("#")) {
                continue;
            }
            String[] kv = line.split("=");
            if (kv.length<2) continue;

            String coords = kv[0].trim(); 
            String val = kv[1].trim();
            String[] xy = coords.split(",");
            if (xy.length<2) continue;

            int x = Integer.parseInt(xy[0]);
            int y = Integer.parseInt(xy[1]);
            int type = Integer.parseInt(val);

            switch(type) {
                case 0: // Indestructible
                    setTile(x,y, WALL_INDESTRUCTIBLE);
                    break;
                case 1: // Destructible
                    setTile(x,y, WALL_DESTRUCTIBLE);
                    break;
                case 2: // Entrance
                    entranceX = x; entranceY = y;
                    break;
                case 3: // Enemy
                    enemySpawns.add(new EnemySpawn(x,y));
                    break;
                case 4: // Exit
                    exitX=x; exitY=y;
                    // We can also place a destructible wall here if you want
                    break;
                case 5: // concurrency power-up
                    powerUpSpawns.add(new PowerUpSpawn(x,y,5));
                    break;
                case 6: // blast radius power-up
                    powerUpSpawns.add(new PowerUpSpawn(x,y,6));
                    break;
                // etc. 
                default:
                    // unknown
                    break;
            }
        }
    }

    /**
     * Destroy a destructible wall at (x, y), turning it into floor.
     */
    public void destroyWall(int x, int y) {
        if (getTile(x,y) == WALL_DESTRUCTIBLE) {
            setTile(x,y, FLOOR);
        }
    }

    // Small record for storing enemy spawns
    public static class EnemySpawn {
        public final int x, y;
        public EnemySpawn(int x, int y) { this.x=x; this.y=y; }
    }

    public static class PowerUpSpawn {
        public final int x, y;
        public final int type; // 5 => concurrency, 6 => blast radius
        public PowerUpSpawn(int x,int y,int type){
            this.x=x; this.y=y; this.type=type;
        }
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/DestructibleWall.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.World;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * DestructibleWall is a subclass of WallPath that can be destroyed.
 */
public class DestructibleWall extends WallPath {

    /**
     * Constructs a DestructibleWall with the specified position, dimensions, and texture region.
     *
     * @param x             The initial x-coordinate of the wall.
     * @param y             The initial y-coordinate of the wall.
     * @param width         The width of the wall.
     * @param height        The height of the wall.
     * @param textureRegion The TextureRegion for the static appearance of the wall.
     */
    public DestructibleWall(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(world, x, y, width, height, textureRegion);
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return True because this is a destructible wall.
     */
    @Override
    public boolean isDestructible() {
        return true;
    }

    /**
     * Destroys the wall/path by setting the isDestroyed flag to true.
     */
    @Override
    public void destroy() {
        if (!isDestroyed) {
            this.isDestroyed = true;
            body.getWorld().destroyBody(body);
        }
    }
}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Object.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;

/**
 * The GameObject class serves as a base class for game objects in the scene.(Enemy, Entrance, Exit)
 * It extends the LibGDX Actor class and provides common properties and methods for game objects.
 *
 * @see com.badlogic.gdx.scenes.scene2d.Actor
 */
public class Object extends Actor {

    /** The x-coordinate of the game object. */
    protected float x;

    /** The y-coordinate of the game object. */
    protected float y;

    /** The width of the game object. */
    protected float width = 64;

    /** The height of the game object. */
    protected float height = 64;

    /** The animation used for dynamic game objects. */
    protected Animation<TextureRegion> animation;

    /** The current animation time for dynamic game objects. */
    protected float animationTime = 0;

    /** The sinus input used for certain animations or behaviors. */
    protected float sinusInput = 0f;

    /** The texture region representing the visual appearance of the game object. */
    protected TextureRegion textureRegion;

    /** The texture of the game object (might be null if using animation). */
    protected Texture texture;

    /** The speed of the game object (might be used in subclasses). */
    protected float speed;

    /**
     * Constructs a GameObject with the specified position, dimensions, and animation.
     *
     * @param x           The x-coordinate of the game object.
     * @param y           The y-coordinate of the game object.
     * @param animation   The animation for dynamic game objects.
     */
    public Object(float x, float y, Animation<TextureRegion> animation) {
        this.x = x;
        this.y = y;
        this.animation = animation;
    }


    /**
     * Checks if this game object collides with another game object.
     *
     * @param object  The other game object to check for collision.
     * @return True if a collision occurs, false otherwise.
     */
    public boolean collidesWith(Object object) {
        boolean above = y + height - 20 > object.getY();
        boolean below = y + 10 < object.getY() + object.getHeight();
        boolean left = x + 3 < object.getX() + object.getWidth();
        boolean right = x + width > object.getX();
        return above && below && left && right;
    }

    /**
     * Draws the game object using the specified SpriteBatch, position, dimensions, and delta time.
     *
     * @param batch   The SpriteBatch used for drawing.
     * @param x       The x-coordinate at which to draw the game object.
     * @param y       The y-coordinate at which to draw the game object.
     * @param delta   The time elapsed since the last draw.
     * @param width   The width at which to draw the game object.
     * @param height  The height at which to draw the game object.
     */
    public void draw(SpriteBatch batch, float x, float y, float delta, float width, float height) {
        animationTime += delta;
        TextureRegion currentFrame = animation.getKeyFrame(animationTime, true);
        batch.draw(currentFrame, x, y, width, height);
    }

    /**
     * Updates the game object based on the elapsed time since the last update.
     *
     * @param delta  The time elapsed since the last update.
     */
    public void update(float delta) {
    }

    // Getters and setters
    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public float getWidth() {
        return width;
    }

    public float getHeight() {
        return height;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void setWidth(float width) {
        this.width = width;
    }

    public void setHeight(float height) {
        this.height = height;
    }

    public float getSinusInput() {
        return sinusInput;
    }

    public TextureRegion getTextureRegion() {
        return textureRegion;
    }

    public Texture getTexture() {
        return texture;
    }

    public float getSpeed() {
        return speed;
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/IndestructibleWall.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.World;

/**
 * IndestructibleWall is a subclass of WallPath that cannot be destroyed.
 */
public class IndestructibleWall extends WallPath  {

    /**
     * Constructs an IndestructibleWall with the specified position, dimensions, and texture region.
     *
     * @param x             The initial x-coordinate of the wall.
     * @param y             The initial y-coordinate of the wall.
     * @param width         The width of the wall.
     * @param height        The height of the wall.
     * @param textureRegion The TextureRegion for the static appearance of the wall.
     */
    public IndestructibleWall(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(world, x, y, width, height, textureRegion);
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return False because this is an indestructible wall.
     */
    @Override
    public boolean isDestructible() {
        return false;
    }

    /**
     * Indestructible walls cannot be destroyed, so this method does nothing.
     */
    @Override
    public void destroy() {
        // No action needed for indestructible walls.
    }

}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Entrance.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * The Entrance class represents the starting point of the player in the game.
 * It extends the Object class and provides functionality specific to the entrance object.
 *
 * The Entrance serves as the spawn point for the player at the beginning of the game.
 * It is visually represented by a texture and does not require any dynamic animation.
 *
 * @see Object
 */
public class Entrance extends Object implements Drawable {

    /**
     * Constructs an Entrance object with the specified position and texture region.
     *
     * @param x             The x-coordinate of the entrance.
     * @param y             The y-coordinate of the entrance.
     * @param textureRegion The texture region representing the entrance's visual appearance.
     */
    public Entrance(float x, float y, TextureRegion textureRegion) {
        super(x, y, null); // No animation needed for the Entrance.
        this.textureRegion = textureRegion; // Set the visual representation of the entrance.
        this.width = 64; // Default width
        this.height = 64; // Default height
    }

    /**
     * Draws the entrance using the specified SpriteBatch and dimensions.
     *
     * @param batch The SpriteBatch used for rendering the entrance.
     * @param delta The time elapsed since the last draw.
     */

    public void draw(SpriteBatch batch, float delta) {
        if (textureRegion != null) {
            batch.draw(textureRegion, x, y, width, height);
        }
    }

    /**
     * Updates the entrance object.
     * Since the entrance does not have dynamic behavior, this method is empty.
     *
     * @param delta The time elapsed since the last update.
     */
    @Override
    public void update(float delta) {
        // No dynamic updates needed for the entrance.
    }

    @Override
    public TextureRegion getCurrentAppearance() {
        // just return this.textureRegion
        return textureRegion;
    }

    @Override
    public float getX() {
        return x;  // ‘x’ is inherited from parent
    }

    @Override
    public float getY() {
        return y;
    }
}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Player.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

import de.tum.cit.ase.bomberquest.audio.SoundEffects;
import de.tum.cit.ase.bomberquest.texture.Animations;

/**
 * The Player moves tile-by-tile and can place bombs.
 */
public class Player {

    private int tileX, tileY;
    private Direction currentDirection = Direction.DOWN;
    private boolean isMoving = false;
    private final TileMap tileMap;
    private final GameMapLogic logic; // We'll store or reference an external logic that holds bombs etc.
    // We'll have four separate animations
    private float animationTime = 0f;

    private int bombCapacity = 1;
    private int bombsActive = 0;
    private int bombRadius = 1;

    public enum Direction {
        UP, DOWN, LEFT, RIGHT
    }

    public Player(TileMap tileMap, int startX, int startY, GameMapLogic logic) {
        this.tileMap = tileMap;
        this.tileX = startX;
        this.tileY = startY;
        this.logic = logic;

        this.animationTime = 0f;
    }

    public void update(float delta) {
        isMoving = false;
        int dx=0, dy=0;

        // Check input
        if (Gdx.input.isKeyJustPressed(Input.Keys.UP)) {
            tryMove(0, 1);
            currentDirection = Direction.UP;
        }
        else if (Gdx.input.isKeyJustPressed(Input.Keys.DOWN)) {
            tryMove(0, -1);
            currentDirection = Direction.DOWN;
        }
        else if (Gdx.input.isKeyJustPressed(Input.Keys.LEFT)) {
            tryMove(-1, 0);
            currentDirection = Direction.LEFT;
        }
        else if (Gdx.input.isKeyJustPressed(Input.Keys.RIGHT)) {
            tryMove(1, 0);
            currentDirection = Direction.RIGHT;
        }

        // If any movement happened, isMoving = true
        // (You could also do this inside tryMove if it actually changes tileX/tileY.)
        if (dx != 0 || dy != 0) {
            isMoving = true;
        }

        // Update animation time only if moving
        if (isMoving) {
            animationTime += delta;
        }

        // Place bomb if SPACE pressed
        if (Gdx.input.isKeyJustPressed(Input.Keys.SPACE)) {
            attemptPlaceBomb();
        }
    }

    private void tryMove(int dx, int dy) {
        int nx = tileX + dx;
        int ny = tileY + dy;
        if (!tileMap.isBlocked(nx, ny)) {
            tileX = nx;
            tileY = ny;
        }
    }

    private void attemptPlaceBomb() {
        if (bombsActive < bombCapacity) {
            // place a bomb
            logic.addBomb(new Bomb(tileX, tileY, bombRadius, logic));
            bombsActive++;

            // PLAY SOUND
            SoundEffects.BOMB_PLACE.play();
        }
    }

    public void bombExploded() {
        bombsActive = Math.max(0, bombsActive-1);
    }

    public void increaseBombRadius() {
        bombRadius = Math.min(bombRadius+1, 8);
    }

    public void increaseBombCapacity() {
        bombCapacity = Math.min(bombCapacity+1, 8);
    }

    public void render(SpriteBatch batch, float tileSizePx) {
        float px = tileX * tileSizePx;
        float py = tileY * tileSizePx;

        // Decide which direction's animation we want
        TextureRegion currentFrame;
        switch (currentDirection) {
            case UP:
                currentFrame = Animations.PLAYER_UP.getKeyFrame(animationTime, true);
                break;
            case DOWN:
                currentFrame = Animations.PLAYER_DOWN.getKeyFrame(animationTime, true);
                break;
            case LEFT:
                currentFrame = Animations.PLAYER_LEFT.getKeyFrame(animationTime, true);
                break;
            case RIGHT:
            default:
                currentFrame = Animations.PLAYER_RIGHT.getKeyFrame(animationTime, true);
                break;
        }

        batch.draw(currentFrame, px, py);
    }



    public int getTileX() { return tileX; }
    public int getTileY() { return tileY; }
    public int getBombRadius() { return bombRadius; }
    public int getBombCapacity() { return bombCapacity; }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Chest.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.*;
import de.tum.cit.ase.bomberquest.texture.Drawable;
import de.tum.cit.ase.bomberquest.texture.Textures;

/**
 * A chest is a static object with a hitbox, so the player cannot walk through it.
 */
public class Chest implements Drawable {
    
    // We would normally get the position from the hitbox, but since we don't need to move the chest, we can store the position directly.
    private final float x;
    private final float y;
    
    /**
     * Create a chest at the given position.
     * @param world The Box2D world to add the chest's hitbox to.
     * @param x The X position.
     * @param y The Y position.
     */
    public Chest(World world, float x, float y) {
        this.x = x;
        this.y = y;
        // Since the hitbox never moves, and we never need to change it, we don't need to store a reference to it.
        createHitbox(world);
    }
    
    /**
     * Create a Box2D body for the chest.
     * @param world The Box2D world to add the body to.
     */
    private void createHitbox(World world) {
        // BodyDef is like a blueprint for the movement properties of the body.
        BodyDef bodyDef = new BodyDef();
        // Static bodies never move, but static bodies can collide with them.
        bodyDef.type = BodyDef.BodyType.StaticBody;
        // Set the initial position of the body.
        bodyDef.position.set(this.x, this.y);
        // Create the body in the world using the body definition.
        Body body = world.createBody(bodyDef);
        // Now we need to give the body a shape so the physics engine knows how to collide with it.
        // We'll use a polygon shape for the chest.
        PolygonShape box = new PolygonShape();
        // Make the polygon a square with a side length of 1 tile.
        box.setAsBox(0.5f, 0.5f);
        // Attach the shape to the body as a fixture.
        body.createFixture(box, 1.0f);
        // We're done with the shape, so we should dispose of it to free up memory.
        box.dispose();
        // Set the chest as the user data of the body so we can look up the chest from the body later.
        body.setUserData(this);
    }
    
    @Override
    public TextureRegion getCurrentAppearance() {
        return Textures.CHEST;
    }
    
    @Override
    public float getX() {
        return x;
    }
    
    @Override
    public float getY() {
        return y;
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/map/GameMapLogic.java ---

package de.tum.cit.ase.bomberquest.map;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import de.tum.cit.ase.bomberquest.audio.SoundEffects;

/**
 * Manages the tile-based logic: bombs, enemies, powerups, 
 * destruction of walls, killing player, etc.
 */
public class GameMapLogic {

    private final TileMap tileMap;
    private Player player;

    private final List<Bomb> bombs = new ArrayList<>();
    private final List<Enemy> enemies = new ArrayList<>();
    private final List<PowerUp> powerUps = new ArrayList<>();

    private boolean gameOver = false;
    private String gameOverReason = "";
    private boolean exitUnlocked = false;

    public GameMapLogic(TileMap tileMap, Player player) {
        this.tileMap = tileMap;
        this.player = player;
    }

    public void addBomb(Bomb bomb) {
        bombs.add(bomb);
    }

    /**
     * Called each frame from GameScreen.
     */
    public void update(float delta) {
        if (gameOver) return; // Freeze logic if game ended

        // 1) Update bombs in a safe iterator loop
        Iterator<Bomb> bombIt = bombs.iterator();
        while (bombIt.hasNext()) {
            Bomb b = bombIt.next();
            b.update(delta);
            if (b.isDone()) {
                bombIt.remove();
                player.bombExploded();
            }
        }
        // => While bombs update, any enemies killed by handleExplosionTile(...) are removed from enemies.

        // 2) Now update enemies AFTER bombs are finished,
        //    using a simple index loop. That way, if handleExplosionTile
        //    removed some enemies, we won't trigger concurrency issues.
        for (int i = enemies.size() - 1; i >= 0; i--) {
            Enemy e = enemies.get(i);
            e.update(delta);

            // If you ever needed to remove an enemy from inside e.update(...),
            // you would mark it dead in Enemy and remove it here:
            //   if (e.isDead()) enemies.remove(i);
        }

        // 3) Check if player stands on a power‐up
        Iterator<PowerUp> pIt = powerUps.iterator();
        while (pIt.hasNext()) {
            PowerUp p = pIt.next();
            // If the player is on that tile => apply powerup => remove
            if (p.getTileX() == player.getTileX() && p.getTileY() == player.getTileY()) {
                if (p.getPowerType() == 5) player.increaseBombCapacity();
                else if (p.getPowerType() == 6) player.increaseBombRadius();

                // PLAY SOUND
                SoundEffects.POWER_UP.play();
                pIt.remove();
            }
        }

        // Check if all enemies are dead => unlock exit
        if (!exitUnlocked && enemies.isEmpty()) {
            exitUnlocked = true;
            System.out.println("All enemies dead -> exit is unlocked!");
        }

        if (exitUnlocked) {
            if (player.getTileX() == tileMap.getExitX() 
                && player.getTileY() == tileMap.getExitY()) {
                // player stands on the exit => victory
                victory();
            }
        }
    }

    private void victory() {
        this.gameOver = true;
        this.gameOverReason = "Victory";
        System.out.println("Player reached the exit => Victory!");
    }

    /**
     * The bomb calls this to damage the tile (x,y). 
     * If it's an indestructible wall => returns true => stop blast.
     * If it's destructible => destroy & return false => keep going
     * Also kills any enemy or the player if they occupy that tile.
     */
    public boolean handleExplosionTile(int x, int y) {
        // Out of bounds => block
        if (x<0 || x>=tileMap.getWidth()||y<0||y>=tileMap.getHeight()) {
            return true;
        }

        int t = tileMap.getTile(x,y);
        if (t == TileMap.WALL_INDESTRUCTIBLE) {
            // block
            return true;
        } else if (t == TileMap.WALL_DESTRUCTIBLE) {
            // destroy it
            tileMap.destroyWall(x, y);
            // we do not block further
            return false;
        }

        // kill enemies in that tile
        for (int i = enemies.size() - 1; i >= 0; i--) {
            Enemy e = enemies.get(i);
            if (e.getTileX() == x && e.getTileY() == y) {
                enemies.remove(i);
            }
        }

        // kill player if in that tile
        if (player.getTileX()==x && player.getTileY()==y) {
            killPlayer("Bomb explosion");
        }

        return false;
    }

    public void killPlayer(String reason) {
        this.gameOver = true;
        this.gameOverReason = reason;
        System.out.println("Player died: " + reason);

        SoundEffects.DIE.play();
    }

    public boolean isGameOver() {
        return gameOver;
    }
    public String getGameOverReason(){return gameOverReason;}

    public Player getPlayer() { return player; }
    public GameMapLogic setPlayer(Player player) {
        this.player = player;
        return this;
    }

    public List<Enemy> getEnemies() { return enemies; }
    public List<Bomb> getBombs() { return bombs; }
    public List<PowerUp> getPowerUps(){ return powerUps; }

    // Add convenience for spawning
    public void addEnemy(Enemy e) {
        enemies.add(e);
    }
    public void addPowerUp(PowerUp p){
        powerUps.add(p);
    }

    public boolean isExitUnlocked() {
        return exitUnlocked;
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/WallPath.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.physics.box2d.*;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * WallPath is an abstract class that represents a wall or path in the game map.
 * It no longer uses animation, and it directly handles a static texture.
 */
public abstract class WallPath extends Object implements Drawable{

    private static final float TILE_SIZE = 32.0f;

    protected Rectangle bounds;
    protected TextureRegion textureRegion;
    protected boolean isDestroyed;
    protected final Body body;

    /**
     * Constructs a WallPath object.
     *
     * @param x             X position of the wall/path.
     * @param y             Y position of the wall/path.
     * @param width         Width of the wall/path.
     * @param height        Height of the wall/path.
     * @param textureRegion TextureRegion to render for the wall/path.
     */
    public WallPath(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(x, y, null);  // No animation for the wall, passing null for animation.

        if (textureRegion == null) {
            throw new IllegalArgumentException("TextureRegion cannot be null for WallPath object.");
        }
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Width and height must be positive.");
        }

        this.bounds = new Rectangle(x, y, width, height);
        this.textureRegion = textureRegion;
        this.isDestroyed = false;

        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.StaticBody;
        bodyDef.position.set(x + width / 2, y + height / 2);
        this.body = world.createBody(bodyDef);

        PolygonShape shape = new PolygonShape();
        shape.setAsBox(width / 2, height / 2);

        FixtureDef fixtureDef = new FixtureDef();
        fixtureDef.shape = shape;
        fixtureDef.density = 1.0f;
        fixtureDef.friction = 0.5f;
        fixtureDef.restitution = 0.0f;
        fixtureDef.isSensor = false;

        this.body.createFixture(fixtureDef);
        this.body.setUserData(this);

        shape.dispose();
    }

    /**
     * Renders the wall/path if it is not destroyed.
     *
     * @param batch The SpriteBatch used to draw the texture.
     */
    @Override
    public void draw(SpriteBatch batch, float x, float y, float delta, float width, float height) {
        if (!isDestroyed && textureRegion != null) {
            batch.draw(textureRegion, x, y, width, height);
        }
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return True if destructible, false otherwise.
     */
    public abstract boolean isDestructible();

    /**
     * Destroys the wall/path, if applicable.
     */
    public abstract void destroy();

    /**
     * Gets the bounding rectangle for collision or placement purposes.
     *
     * @return The bounds of the wall/path.
     */
    public Rectangle getBounds() {
        return bounds;
    }

    /**
     * Checks if the wall/path has been destroyed.
     *
     * @return True if destroyed, false otherwise.
     */
    public boolean isDestroyed() {
        return isDestroyed;
    }

    /**
     * Disposes of resources associated with this wall/path.
     */
    public void dispose() {
        if (textureRegion != null) {
            // Optionally dispose the texture associated with the texture region
            textureRegion.getTexture().dispose();
        }
    }
    public TextureRegion getCurrentAppearance() {
        return textureRegion;
    }

}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Exit.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents the exit point in the game.
 */
public class Exit extends Object implements Drawable {
    /** A flag indicating whether the exit has been unlocked (all enemies defeated). */
    private boolean unlocked;

    /** A flag indicating whether the exit is revealed after the wall is destroyed. */
    private boolean revealed;

    /** The wall above the exit (a destructible wall). */
    private WallPath wallAboveExit;

    /**
     * Constructs an Exit object with the specified position, dimensions, animation, and wall above it.
     *
     * @param x           The x-coordinate of the exit.
     * @param y           The y-coordinate of the exit.
     * @param textureRegion  The animation representing the exit's appearance.
     * @param wallAboveExit  The wall above the exit that must be destroyed to reveal the exit.
     */
    public Exit(float x, float y, TextureRegion textureRegion, WallPath wallAboveExit) {
        super(x, y, null);
        this.textureRegion = textureRegion; // Set the visual representation of the entrance.
        this.width = 64; // Default width
        this.height = 64; // Default height
        this.wallAboveExit = wallAboveExit;
        this.unlocked = false;
        this.revealed = false;
    }

    /**
     * Unlocks the exit after all enemies are defeated in the maze.
     */
    public void unlockExit() {
        this.unlocked = true;
    }

    /**
     * Reveals the exit by destroying the wall above it.
     */
    public void revealExit() {
        if (wallAboveExit != null && wallAboveExit.isDestroyed()) {
            this.revealed = true;
        }
    }

    /**
     * Checks if the exit is accessible (unlocked and revealed).
     *
     * @return True if the exit is unlocked and revealed, false otherwise.
     */
    public boolean isAccessible() {
        return unlocked && revealed;
    }

    /**
     * Updates the exit based on the elapsed time since the last update.
     * This method also checks if the wall above it is destroyed and updates the revealed status.
     *
     * @param delta  The time elapsed since the last update.
     */
    @Override
    public void update(float delta) {
        super.update(delta);
        // Check if the exit should be revealed after the wall is destroyed.
        revealExit();
    }

    /**
     * Renders the exit using the specified SpriteBatch.
     * If the exit is revealed, the exit will be drawn.
     * If not, the exit will remain hidden beneath the destructible wall.
     *
     * @param spriteBatch  The SpriteBatch used for rendering.
     */
    @Override
    public void draw(SpriteBatch spriteBatch, float x, float y, float delta, float width, float height) {
        if (revealed && isAccessible()) {
            // Draw the exit only if it's revealed and accessible
            super.draw(spriteBatch, x, y, delta, width, height);
        }
    }

    // Getters and setters
    public boolean isUnlocked() {
        return unlocked;
    }

    public boolean isRevealed() {
        return revealed;
    }

    public WallPath getWallAboveExit() {
        return wallAboveExit;
    }

    public void setWallAboveExit(WallPath wallAboveExit) {
        this.wallAboveExit = wallAboveExit;
    }
    @Override
    public TextureRegion getCurrentAppearance() {
        // just return this.textureRegion
        return textureRegion;
    }

    @Override
    public float getX() {
        return x;  // ‘x’ is inherited from parent
    }

    @Override
    public float getY() {
        return y;
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/GameScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.viewport.ExtendViewport;
import de.tum.cit.ase.bomberquest.BomberQuestGame;
import de.tum.cit.ase.bomberquest.audio.MusicTrack;
import de.tum.cit.ase.bomberquest.map.*;
import de.tum.cit.ase.bomberquest.texture.Textures;

public class GameScreen implements Screen {

    private final BomberQuestGame game;

    // We'll use a 320×240 "world size" to start with. If the window is bigger,
    // the user just sees more of the map.
    private static final float WORLD_WIDTH = 320;
    private static final float WORLD_HEIGHT = 240;

    private OrthographicCamera camera;
    private ExtendViewport viewport;
    private SpriteBatch batch;
    private ShapeRenderer shapeRenderer;

    private TileMap tileMap;
    private GameMapLogic logic; 
    private Player player;
    private Hud hud;

    private float tileSizePx = 16f; // each tile is 16×16
    private float timeLeft = 300f;

    public GameScreen(BomberQuestGame game, String mapFile) {
        this.game = game;

        camera = new OrthographicCamera();
        viewport = new ExtendViewport(WORLD_WIDTH, WORLD_HEIGHT, camera);
        batch = game.getSpriteBatch();

        shapeRenderer = new ShapeRenderer();

        // 1) Load the tileMap from map.properties
        tileMap = new TileMap(40,24); // if you know it's 40×24
        tileMap.loadFromProperties(mapFile);

        // 3) Create the logic that holds bombs, enemies, powerups
        logic = new GameMapLogic(tileMap, player);

        // Suppose you have Textures.CHARACTER or something
        player = new Player(tileMap, tileMap.getEntranceX(), tileMap.getEntranceY(), logic);
        logic.setPlayer(player);

        // 4) Spawn enemies from tileMap enemySpawns
        for (TileMap.EnemySpawn es : tileMap.getEnemySpawns()) {
            TextureRegion eSprite = Textures.ENEMY; 
            Enemy e = new Enemy(tileMap, es.x, es.y, logic);
            logic.addEnemy(e);
        }

        // 5) Spawn powerUps
        for (TileMap.PowerUpSpawn pus : tileMap.getPowerUpSpawns()) {
            TextureRegion pSprite = (pus.type==5) ? Textures.POWER_UP_GREEN : Textures.POWER_UP_RED;
            PowerUp p = new PowerUp(pus.x, pus.y, pus.type, pSprite);
            logic.addPowerUp(p);
        }

        // Instantiate HUD (reusing the same SpriteBatch and a simple BitmapFont):
        // If you already have a separate font, pass that instead of a new BitmapFont().
        this.hud = new Hud(game.getSpriteBatch(), new BitmapFont());
    }

    @Override
    public void render(float delta) {
            // If the player hits ESC, pause the game
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            game.setScreen(new PauseMenuScreen(game, this));
            return; // skip the rest of the render
        }
        
        if (logic.isGameOver()) {
            game.setScreen(
                new GameOverScreen(
                    game,
                    logic.getGameOverReason(),  // e.g. "Bomb explosion" or "Timer expired"
                    game.getSkin()
                )
            );
            return;
        }

        // -- 1) Update countdown timer
        timeLeft -= delta;
        if (timeLeft <= 0) {
            // Time ran out -> end the game
            System.out.println("Game Over - Timer has expired!");
            game.goToMenu();
            return;
        }

        // -- 2) Update gameplay logic
        player.update(delta);
        logic.update(delta);

        // -- 3) Update camera and draw map/objects
        clampCamera80Percent();
        camera.update();
        batch.setProjectionMatrix(camera.combined);

        ScreenUtils.clear(Color.BLACK);

        batch.begin();

        // draw the tile-based map
        for (int y=0; y<tileMap.getHeight(); y++) {
            for (int x=0; x<tileMap.getWidth(); x++) {
                int t = tileMap.getTile(x,y);
                TextureRegion region = getTileTexture(t);
                float px = x*tileSizePx;
                float py = y*tileSizePx;
                batch.draw(region, px, py);
            }
        }

        // draw powerUps
        for (PowerUp p : logic.getPowerUps()) {
            p.render(batch, tileSizePx);
        }

        for (Bomb b : logic.getBombs()) {
            b.renderFuse(batch, tileSizePx); // only the fuse animation
        }

        // draw enemies
        for (Enemy e : logic.getEnemies()) {
            e.render(batch, tileSizePx);
        }

        // draw player
        player.render(batch, tileSizePx);

        batch.end();

        // B) Now draw the shape-based explosions in one pass
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);

        for (Bomb b : logic.getBombs()) {
            b.renderExplosion(shapeRenderer, tileSizePx);
        }

        shapeRenderer.end();

                // -- 4) Render the HUD on top of everything
        // Number of enemies left
        int enemiesLeft = logic.getEnemies().size();
        // For a simple “exit unlocked” check, assume “unlocked if all enemies are dead”
        boolean exitUnlocked = (enemiesLeft == 0);

        hud.render(
            player,
            timeLeft,
            enemiesLeft,
            exitUnlocked
        );
    }

    /**
     * Clamps the camera so the player is within the middle 80% of the screen,
     * and we don't show beyond the map edges.
     */
    private void clampCamera80Percent() {
        float camW = viewport.getWorldWidth();
        float camH = viewport.getWorldHeight();

        float marginX = camW*0.1f;
        float marginY = camH*0.1f;

        // player's pixel coords
        float playerPxX = player.getTileX()*tileSizePx;
        float playerPxY = player.getTileY()*tileSizePx;

        float leftLimit = camera.position.x - camW/2f + marginX;
        float rightLimit= camera.position.x + camW/2f - marginX;
        float downLimit = camera.position.y - camH/2f + marginY;
        float upLimit   = camera.position.y + camH/2f - marginY;

        // adjust horizontally
        if (playerPxX < leftLimit) {
            camera.position.x -= (leftLimit - playerPxX);
        } else if (playerPxX > rightLimit) {
            camera.position.x += (playerPxX - rightLimit);
        }

        // adjust vertically
        if (playerPxY < downLimit) {
            camera.position.y -= (downLimit - playerPxY);
        } else if (playerPxY > upLimit) {
            camera.position.y += (playerPxY - upLimit);
        }

        // clamp so we don't go outside map
        float mapW = tileMap.getWidth()*tileSizePx;
        float mapH = tileMap.getHeight()*tileSizePx;

        float halfW = camW/2f;
        float halfH = camH/2f;

        // clamp X
        if (camW < mapW) {
            if (camera.position.x < halfW) camera.position.x=halfW;
            if (camera.position.x > mapW-halfW) camera.position.x= mapW-halfW;
        } else {
            // if map is narrower than cam => center
            camera.position.x = mapW/2f;
        }

        // clamp Y
        if (camH < mapH) {
            if (camera.position.y < halfH) camera.position.y=halfH;
            if (camera.position.y > mapH-halfH) camera.position.y= mapH-halfH;
        } else {
            camera.position.y = mapH/2f;
        }
    }

    private TextureRegion getTileTexture(int tileType){
        // 0 => floor, 1 => inde, 2 => destructive
        switch(tileType) {
            case TileMap.WALL_INDESTRUCTIBLE: return Textures.INDEST_WALL;
            case TileMap.WALL_DESTRUCTIBLE: return Textures.DEST_WALL;
            default: 
                // treat as floor
                return Textures.TILES; 
        }
    }

    @Override
    public void resize(int width, int height) {
        viewport.update(width,height,false);
        // Also let the HUD know about the new screen size
        hud.resize(width, height);
    }

    @Override
    public void show() {
        MusicTrack.MENU.stop();
        MusicTrack.BACKGROUND.play();
    }
    @Override
    public void hide() {
        MusicTrack.BACKGROUND.stop();
    }
    @Override
    public void pause() {}
    @Override
    public void resume() {}
    @Override
    public void dispose() {
        shapeRenderer.dispose();
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/MenuScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import com.badlogic.gdx.utils.viewport.Viewport;
import de.tum.cit.ase.bomberquest.BomberQuestGame;
import de.tum.cit.ase.bomberquest.audio.MusicTrack;

/**
 * The MenuScreen class is responsible for displaying the main menu of the game.
 * It extends the LibGDX Screen class and sets up the UI components for the menu.
 */
public class MenuScreen implements Screen {

    private final Stage stage;

    /**
     * Constructor for MenuScreen. Sets up the camera, viewport, stage, and UI elements.
     *
     * @param game The main game class, used to access global resources and methods.
     */
    public MenuScreen(BomberQuestGame game) {
        var camera = new OrthographicCamera();
        camera.zoom = 1.5f; // Set camera zoom for a closer view

        Viewport viewport = new ScreenViewport(camera); // Create a viewport with the camera
        stage = new Stage(viewport, game.getSpriteBatch()); // Create a stage for UI elements

        Table table = new Table(); // Create a table for layout
        table.setFillParent(true); // Make the table fill the stage
        stage.addActor(table); // Add the table to the stage

        // Add a label as a title
        table.add(new Label("Hello World from the Menu!", game.getSkin(), "title")).padBottom(80).row();

        // Create and add a button to go to the game screen
        TextButton goToGameButton = new TextButton("Go To Game", game.getSkin());
        table.add(goToGameButton).width(300).row();
        goToGameButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.goToGame(); // Change to the game screen when button is pressed
            }
        });
    }

    /**
     * The render method is called every frame to render the menu screen.
     * It clears the screen and draws the stage.
     * @param deltaTime The time in seconds since the last render.
     */
    @Override
    public void render(float deltaTime) {
        float frameTime = Math.min(deltaTime, 0.250f); // Cap frame time to 250ms to prevent spiral of death        ScreenUtils.clear(Color.BLACK);
        ScreenUtils.clear(Color.BLACK); // Clear the screen
        stage.act(frameTime); // Update the stage
        stage.draw(); // Draw the stage
    }

    /**
     * Resize the stage when the screen is resized.
     * @param width The new width of the screen.
     * @param height The new height of the screen.
     */
    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true); // Update the stage viewport on resize
    }

    @Override
    public void dispose() {
        // Dispose of the stage when screen is disposed
        stage.dispose();
    }

    @Override
    public void show() {
        MusicTrack.MENU.play();
        // Set the input processor so the stage can receive input events
        Gdx.input.setInputProcessor(stage);
    }

    // The following methods are part of the Screen interface but are not used in this screen.
    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
        MusicTrack.MENU.stop();
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/Hud.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;

import de.tum.cit.ase.bomberquest.map.Exit;
import de.tum.cit.ase.bomberquest.map.Player;

/**
 * A Heads-Up Display (HUD) that displays information on the screen.
 * It uses a separate camera so that it is always fixed on the screen.
 */
public class Hud {
    private OrthographicCamera hudCamera;
    private SpriteBatch batch;
    private BitmapFont font;

    public Hud(SpriteBatch batch, BitmapFont font) {
        this.batch = batch;
        this.font = font;
        this.font.getData().setScale(2.5f);
        hudCamera = new OrthographicCamera();
    }

    public void render(Player player, float timeLeft, int enemiesLeft, boolean exitUnlocked) {
        batch.setProjectionMatrix(hudCamera.combined);
        batch.begin();

        // Build a single line of text
        // You can break this into two lines or more if you want to split it.
        String hudLine = String.format(
            "BombRadius: %d   BombCap: %d   TimeLeft: %d   Enemies: %d   Exit: %s",
            player.getBombRadius(),
            player.getBombCapacity(),
            (int) timeLeft,
            enemiesLeft,
            exitUnlocked ? "Unlocked" : "Locked"
        );

        // Draw near the top-left. Subtract e.g. 10px from the top so it’s not offscreen
        float margin = 10;
        font.getData().setScale(2.5f);
        font.draw(batch, hudLine, margin, hudCamera.viewportHeight - margin);

        batch.end();
    }

    public void resize(int width,int height) {
        hudCamera.setToOrtho(false,width,height);
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/VictoryScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import de.tum.cit.ase.bomberquest.BomberQuestGame;
import de.tum.cit.ase.bomberquest.audio.SoundEffects;

/**
 * The VictoryScreen class represents the screen displayed when the player achieves victory.
 * It provides options to return to the main menu.
 */
public class VictoryScreen implements Screen {

    private final BomberQuestGame game;
    private final Screen previousScreen;
    private Stage stage;
    private final Skin skin;

    /**
     * Creates a new VictoryScreen.
     *
     * @param game           The main game instance
     * @param previousScreen The previous screen to potentially return to
     * @param skin          The skin used for UI elements
     */
    public VictoryScreen(BomberQuestGame game, Screen previousScreen, Skin skin) {
        this.game = game;
        this.previousScreen = previousScreen;
        this.skin = skin;
    }

    @Override
    public void show() {
        stage = new Stage();
        Table table = new Table();
        table.setFillParent(true);
        stage.addActor(table);
        Gdx.input.setInputProcessor(stage);

        // Create victory label with animation
        Label victoryLabel = new Label("Victory!", skin, "title");
        table.add(victoryLabel).padBottom(80).row();

        // Add blinking animation to the victory label
        victoryLabel.addAction(Actions.forever(Actions.sequence(
                Actions.fadeIn(0.7f),
                Actions.fadeOut(0.7f)
        )));

        // Create and add the back to menu button
        TextButton backToMenuButton = new TextButton("Return to Menu", skin);
        table.add(backToMenuButton).padBottom(20).row();

        // Add click listener for the menu button
        backToMenuButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                game.goToMenu();
            }
        });

        // Optional: Add more stats or information about the victory
        Label statsLabel = new Label("Congratulations! You've completed the level!", skin);
        table.add(statsLabel).padTop(20).row();

        // PLAY SOUND
        SoundEffects.WIN.play();
    }

    @Override
    public void render(float delta) {
        // Clear the screen
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Update and draw the stage
        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
    }

    @Override
    public void dispose() {
        if (stage != null) {
            stage.dispose();
        }
    }
    //test
    //sync
}

--- File: core/src/de/tum/cit/ase/bomberquest/screen/GameOverScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.InputEvent;

import de.tum.cit.ase.bomberquest.BomberQuestGame;

/**
 * The GameOverScreen class represents a dedicated screen displayed when the player loses.
 */
public class GameOverScreen implements Screen {

    private final BomberQuestGame game;
    private final String gameOverReason;
    private final Skin skin;
    private Stage stage;

    /**
     * Creates a new GameOverScreen.
     *
     * @param game           The main game instance.
     * @param gameOverReason Reason for the game over (e.g. "Bomb explosion" or "Time ran out").
     * @param skin           The UI skin for styling widgets.
     */
    public GameOverScreen(BomberQuestGame game, String gameOverReason, Skin skin) {
        this.game = game;
        this.gameOverReason = gameOverReason;
        this.skin = skin;
    }

    @Override
    public void show() {
        stage = new Stage();
        Gdx.input.setInputProcessor(stage);

        Table rootTable = new Table();
        rootTable.setFillParent(true);
        stage.addActor(rootTable);

        // Main "Game Over" label
        Label gameOverLabel = new Label("GAME OVER", skin, "title");
        rootTable.add(gameOverLabel).padBottom(20).row();

        // Optional: show the reason the player died
        // (If you don't want to show a reason, you can remove this label.)
        if (gameOverReason != null && !gameOverReason.isEmpty()) {
            Label reasonLabel = new Label("Reason: " + gameOverReason, skin);
            rootTable.add(reasonLabel).padBottom(40).row();
        }

        // Button to go back to the main menu
        TextButton menuButton = new TextButton("Return to Main Menu", skin);
        rootTable.add(menuButton).width(300).height(50).row();

        // When button clicked => go to the menu
        menuButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                game.goToMenu();
            }
        });
    }

    @Override
    public void render(float delta) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void pause() { }
    @Override
    public void resume() { }
    @Override
    public void hide() { }
    @Override
    public void dispose() {
        if (stage != null) {
            stage.dispose();
        }
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Drawable.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Represents something that can be drawn on the screen.
 * NOTE: The position returned by {@link #getX()} and {@link #getY()} is the
 * position of the BOTTOM LEFT CORNER of the texture in the game.
 */
public interface Drawable {
    
    /**
     * Gets the current appearance of the Drawable.
     * This can change over time.
     * @return The current appearance as a {@link TextureRegion}.
     */
    TextureRegion getCurrentAppearance();
    
    /**
     * Gets the X coordinate of the drawable in the game world grid.
     * Note that this is a TILE coordinate, not a pixel coordinate.
     * It must be multiplied by {@link de.tum.cit.ase.bomberquest.screen.GameScreen#TILE_SIZE_PX}
     * and {@link de.tum.cit.ase.bomberquest.screen.GameScreen#SCALE} to get the pixel coordinate.
     * @return The X coordinate of the drawable.
     */
    float getX();
    
    /**
     * Gets the Y coordinate of the drawable in the game world grid.
     * Note that this is a TILE coordinate, not a pixel coordinate.
     * It must be multiplied by {@link de.tum.cit.ase.bomberquest.screen.GameScreen#TILE_SIZE_PX}
     * and {@link de.tum.cit.ase.bomberquest.screen.GameScreen#SCALE} to get the pixel coordinate.
     * @return The Y coordinate of the drawable.
     */
    float getY();
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Textures.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Contains all texture constants used in the game.
 * It is good practice to keep all textures and animations in constants to avoid loading them multiple times.
 * These can be referenced anywhere they are needed.
 */
public class Textures {
    
    public static final TextureRegion FLOWERS = SpriteSheet.BASIC_TILES.at(2, 5);
    public static final TextureRegion TILES = SpriteSheet.BASIC_TILES.at(2, 3);
    public static final TextureRegion DEST_WALL = SpriteSheet.BASIC_TILES.at(1,4 );
    public static final TextureRegion INDEST_WALL = SpriteSheet.BASIC_TILES.at(1,6 );
    public static final TextureRegion CHEST = SpriteSheet.BASIC_TILES.at(5, 5);
    public static final TextureRegion ENTRANCE = SpriteSheet.BASIC_TILES.at(4, 6);
    public static final TextureRegion EXIT = SpriteSheet.BASIC_TILES.at(2,4);
    public static final TextureRegion POWER_UP_GREEN = SpriteSheet.BASIC_TILES.at(3,4);
    public static final TextureRegion POWER_UP_RED = SpriteSheet.BASIC_TILES.at(3,2);
    public static final TextureRegion ENEMY = SpriteSheet.ORIGINAL_BOMBERMAN.at(22,1);
    public static final TextureRegion BOMB = SpriteSheet.BASIC_TILES.at(3, 3);
    
}



--- File: core/src/de/tum/cit/ase/bomberquest/texture/SpriteSheet.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

import de.tum.cit.ase.bomberquest.map.PowerUp;

/**
 * Enumerates all spritesheets used in the game and provides helper methods for grabbing texture regions from them.
 * It is assumed that every spritesheet has some standard grid size which can be used for easier coordinate specification.
 * See the assets/texture folder for the actual texture files (plus some more samples which are not enumerated here).
 * Feel free to add your own spritesheets and use them in the game!
 *
 * @see Texture a whole image
 * @see TextureRegion a part of an image
 */
public enum SpriteSheet {
    
    MOBS("mobs.png", 16, 16),

    /** 16x16 portion of mainFile for bombs (top row). */
    BOMB_SHEET("original-bomberman.png", 16, 16),

    /** 32x32 portion of mainFile for large crosses. */
    BLAST_SHEET("original-bomberman.png", 32, 32),

    /** The character spritesheet, which has a grid size of 16x32. */
    CHARACTER("character.png", 16, 20),
    /** The basic tiles spritesheet, which has a grid size of 16x16. */
    BASIC_TILES("basictiles.png", 16, 16),

    POWER_UP("powerup.png", 16, 16),

    ORIGINAL_BOMBERMAN("original-bomberman.png", 16, 16);
    
private final Texture spritesheet;
    private final int width;
    private final int height;
    
    /**
     * Constructor for each variant of this enum.
     * Every SpriteSheet has a corresponding file, width, and height.
     * @param filename the filename of the spritesheet
     * @param width the width of a single grid cell
     * @param height the height of a single grid cell
     */
    SpriteSheet(String filename, int width, int height) {
        this.spritesheet = new Texture(Gdx.files.internal("texture/" + filename));
        this.width = width;
        this.height = height;
    }
    
    /**
     * Returns the TextureRegion at the specified row and column (1-based coordinates)
     * according to the grid specified by {@code this.width} and {@code this.height}.
     * This method assumes the size of the texture to be a single grid cell.
     * Keep in mind that since spritesheet textures typically start in the top-left corner,
     * the row index starts at 1 at the top and the column index starts at 1 on the left.
     *
     * @param row the row of the texture to fetch, starting from 1 at the TOP of the spritesheet
     * @param column the column of the texture to fetch, starting from 1 on the LEFT of the spritesheet
     * @return the texture
     */
    public TextureRegion at(int row, int column) {
        return new TextureRegion(
                spritesheet,
                (column - 1) * this.width,
                (row - 1) * this.height,
                this.width,
                this.height
        );
    }
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Animations.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Contains all animation constants used in the game.
 * It is good practice to keep all textures and animations in constants
 * to avoid loading them multiple times.
 * These can be referenced anywhere they are needed.
 */
public class Animations {

    public static final Animation<TextureRegion> PLAYER_DOWN;
    public static final Animation<TextureRegion> PLAYER_LEFT;
    public static final Animation<TextureRegion> PLAYER_RIGHT;
    public static final Animation<TextureRegion> PLAYER_UP;

    public static final Animation<TextureRegion> ENEMY_DOWN;
    public static final Animation<TextureRegion> ENEMY_LEFT;
    public static final Animation<TextureRegion> ENEMY_RIGHT;
    public static final Animation<TextureRegion> ENEMY_UP;

    // Bomb fuse: 3 frames (16x16) from top row in BOMB_SHEET
    public static final Animation<TextureRegion> BOMB_FUSE;

    static {
        // We have 4 frames across columns 5..8
        // Row 1 => down, Row 2 => left, Row 3 => right, Row 4 => up
    
        TextureRegion[] downFrames = new TextureRegion[4];
        for (int col = 8; col <= 11; col++) {
            downFrames[col - 8] = SpriteSheet.MOBS.at(1, col);
        }
        PLAYER_DOWN = new Animation<>(0.1f, downFrames);
    
        TextureRegion[] leftFrames = new TextureRegion[4];
        for (int col = 8; col <= 11; col++) {
            leftFrames[col - 8] = SpriteSheet.MOBS.at(2, col);
        }
        PLAYER_LEFT = new Animation<>(0.1f, leftFrames);
    
        TextureRegion[] rightFrames = new TextureRegion[4];
        for (int col = 8; col <= 11; col++) {
            rightFrames[col - 8] = SpriteSheet.MOBS.at(3, col);
        }
        PLAYER_RIGHT = new Animation<>(0.1f, rightFrames);
    
        TextureRegion[] upFrames = new TextureRegion[4];
        for (int col = 8; col <= 11; col++) {
            upFrames[col - 8] = SpriteSheet.MOBS.at(4, col);
        }
        PLAYER_UP = new Animation<>(0.1f, upFrames);
    }

    static {
        // Single-frame "animation" from row=5, col=1 => ENEMY_DOWN
        TextureRegion[] downFrames = new TextureRegion[1];
        downFrames[0] = SpriteSheet.MOBS.at(5, 1);
        ENEMY_DOWN = new Animation<>(0.1f, downFrames);
    
        // Single-frame from row=6, col=1 => ENEMY_LEFT
        TextureRegion[] leftFrames = new TextureRegion[1];
        leftFrames[0] = SpriteSheet.MOBS.at(6, 1);
        ENEMY_LEFT = new Animation<>(0.1f, leftFrames);
    
        // Single-frame from row=7, col=1 => ENEMY_RIGHT
        TextureRegion[] rightFrames = new TextureRegion[1];
        rightFrames[0] = SpriteSheet.MOBS.at(7, 1);
        ENEMY_RIGHT = new Animation<>(0.1f, rightFrames);
    
        // Single-frame from row=8, col=1 => ENEMY_UP
        TextureRegion[] upFrames = new TextureRegion[1];
        upFrames[0] = SpriteSheet.MOBS.at(8, 1);
        ENEMY_UP = new Animation<>(0.1f, upFrames);
    }

    static {
        /*
         * Suppose your bombs appear in row=1 of original-bomberman.png
         * (the top row), columns 1..3, each 16x16. 
         */
        TextureRegion[] fuseFrames = new TextureRegion[3];
        for (int col = 1; col <= 3; col++) {
            fuseFrames[col - 1] = SpriteSheet.BOMB_SHEET.at(4, col);
        }
        BOMB_FUSE = new Animation<>(0.15f, fuseFrames);
        BOMB_FUSE.setPlayMode(Animation.PlayMode.LOOP);
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/entities/Bomb.java ---

package de.tum.cit.ase.bomberquest.entities;

public class Bomb {
}


--- File: desktop/build.gradle ---

java {
    sourceCompatibility = JavaVersion.VERSION_17
}
sourceSets.main.java.srcDirs = [ "src/" ]
sourceSets.main.resources.srcDirs = ["../assets"]

project.ext.mainClassName = "de.tum.cit.ase.bomberquest.DesktopLauncher"
project.ext.assetsDir = new File("../assets")

import org.gradle.internal.os.OperatingSystem

tasks.register('run', JavaExec) {
    dependsOn classes
    mainClass = project.mainClassName
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = file("../")
    ignoreExitValue = true

    if (OperatingSystem.current() == OperatingSystem.MAC_OS) {
        // Required to run on macOS
        jvmArgs += "-XstartOnFirstThread"
    }
}

tasks.register('debug', JavaExec) {
    dependsOn classes
    mainClass = project.mainClassName
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = file("../")
    ignoreExitValue = true
    debug = true
}

tasks.register('dist', Jar) {
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
    manifest {
        attributes 'Main-Class': project.mainClassName
    }
    dependsOn configurations.runtimeClasspath
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    with jar
}


dist.dependsOn classes

eclipse.project.name = appName + "-desktop"


--- File: desktop/src/de/tum/cit/ase/bomberquest/DesktopLauncher.java ---

package de.tum.cit.ase.bomberquest;

import com.badlogic.gdx.Graphics;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration;
import games.spooky.gdx.nativefilechooser.desktop.DesktopFileChooser;



/**
 * The DesktopLauncher class is the entry point for the desktop version of the Bomber Quest game.
 * It sets up the game window and launches the game using LibGDX framework.
 */
public class DesktopLauncher {
	/**
	 * The main method sets up the configuration for the game window and starts the application.
	 *
	 * @param arg Command line arguments (not used in this application)
	 */
	public static void main(String[] arg) {
		// Configuration for the game window
		Lwjgl3ApplicationConfiguration config = new Lwjgl3ApplicationConfiguration();
		config.setTitle("Bomber Quest"); // Set the window title

		// Get the display mode of the current monitor
		Graphics.DisplayMode displayMode = Lwjgl3ApplicationConfiguration.getDisplayMode();
		// Set the window size to 80% of the screen width and height
		config.setWindowedMode(
				Math.round(0.8f * displayMode.width),
				Math.round(0.8f * displayMode.height)
		);
		config.useVsync(true); // Enable vertical sync
		config.setForegroundFPS(60); // Set the foreground frames per second

		System.out.println("Working directory: " + System.getProperty("user.dir"));

		// Launch the game
		new Lwjgl3Application(new BomberQuestGame(new DesktopFileChooser()), config);
	}
}
