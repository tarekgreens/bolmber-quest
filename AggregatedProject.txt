

--- File: core/src/de/tum/cit/ase/bomberquest/BomberQuestGame.java ---

package de.tum.cit.ase.bomberquest;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import de.tum.cit.ase.bomberquest.audio.MusicTrack;
import de.tum.cit.ase.bomberquest.map.DestructibleWall;
import de.tum.cit.ase.bomberquest.map.Entrance;
import de.tum.cit.ase.bomberquest.map.GameMap;
import de.tum.cit.ase.bomberquest.map.IndestructibleWall;
import de.tum.cit.ase.bomberquest.screen.GameScreen;
import de.tum.cit.ase.bomberquest.screen.MenuScreen;
import de.tum.cit.ase.bomberquest.texture.Textures;
import games.spooky.gdx.nativefilechooser.NativeFileChooser;

/**
 * The BomberQuestGame class represents the core of the Bomber Quest game.
 * It manages the screens and global resources like SpriteBatch and Skin.
 */
public class BomberQuestGame extends Game {

    /**
     * Sprite Batch for rendering game elements.
     * This eats a lot of memory, so we only want one of these.
     */
    private SpriteBatch spriteBatch;

    /** The game's UI skin. This is used to style the game's UI elements. */
    private Skin skin;

    /**
     * The file chooser for loading map files from the user's computer.
     * This will give you access to a {@link com.badlogic.gdx.files.FileHandle} object,
     * which you can use to read the contents of the map file as a String, and then parse it into a {@link GameMap}.
     */
    private final NativeFileChooser fileChooser;

    /**
     * The map. This is where all the game objects are stored.
     * This is owned by {@link BomberQuestGame} and not by {@link GameScreen}
     * because the map should not be destroyed if we temporarily switch to another screen.
     */
    private GameMap map;

    /**
     * Constructor for BomberQuestGame.
     *
     * @param fileChooser The file chooser for selecting custom maps.
     */
    public BomberQuestGame(NativeFileChooser fileChooser) {
        this.fileChooser = fileChooser;
    }

    /**
     * Called when the game is created. Initializes the SpriteBatch and Skin.
     * During the class constructor, libGDX is not fully initialized yet.
     * Therefore this method serves as a second constructor for the game,
     * and we can use libGDX resources here.
     */
    @Override
    public void create() {
        this.spriteBatch = new SpriteBatch(); // Create SpriteBatch for rendering
        this.skin = new Skin(Gdx.files.internal("skin/craftacular/craftacular-ui.json")); // Load UI skin
        this.map = new GameMap(this); // Create a new game map (you should change this to load the map from a file instead)
        this.map.loadFromProperties("maps/map.properties");
        MusicTrack.BACKGROUND.play(); // Play some background music
        goToMenu(); // Navigate to the menu screen
    }

    /**
     * Switches to the menu screen.
     */
    public void goToMenu() {
        this.setScreen(new MenuScreen(this)); // Set the current screen to MenuScreen
    }

    /**
     * Switches to the game screen.
     */
    public void goToGame() {
        this.setScreen(new GameScreen(this)); // Set the current screen to GameScreen
    }

    /** Returns the skin for UI elements. */
    public Skin getSkin() {
        return skin;
    }

    /** Returns the main SpriteBatch for rendering. */
    public SpriteBatch getSpriteBatch() {
        return spriteBatch;
    }

    /** Returns the current map, if there is one. */
    public GameMap getMap() {
        return map;
    }

    /**
     * Switches to the given screen and disposes of the previous screen.
     * @param screen the new screen
     */
    @Override
    public void setScreen(Screen screen) {
        Screen previousScreen = super.screen;
        super.setScreen(screen);
        if (previousScreen != null) {
            previousScreen.dispose();
        }
    }

    /** Cleans up resources when the game is disposed. */
    @Override
    public void dispose() {
        getScreen().hide(); // Hide the current screen
        getScreen().dispose(); // Dispose the current screen
        spriteBatch.dispose(); // Dispose the spriteBatch
        skin.dispose(); // Dispose the skin
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/audio/MusicTrack.java ---

package de.tum.cit.ase.bomberquest.audio;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;

/**
 * This enum is used to manage the music tracks in the game.
 * Currently, only one track is used, but this could be extended to include multiple tracks.
 * Using an enum for this purpose is a good practice, as it allows for easy management of the music tracks
 * and prevents the same track from being loaded into memory multiple times.
 * See the assets/audio folder for the actual music files.
 * Feel free to add your own music tracks and use them in the game!
 */
public enum MusicTrack {
    
    BACKGROUND("background.mp3", 0.2f);
    
    /** The music file owned by this variant. */
    private final Music music;
    
    MusicTrack(String fileName, float volume) {
        this.music = Gdx.audio.newMusic(Gdx.files.internal("audio/" + fileName));
        this.music.setLooping(true);
        this.music.setVolume(volume);
    }
    
    /**
     * Play this music track.
     * This will not stop other music from playing - if you add more tracks, you will have to handle that yourself.
     */
    public void play() {
        this.music.play();
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Bomb.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import de.tum.cit.ase.bomberquest.screen.GameScreen;
import de.tum.cit.ase.bomberquest.texture.Textures;

public class Bomb {

    private static final float FUSE_TIME_SECONDS = 3.0f;

    private final int tileX;
    private final int tileY;
    private final int blastRadius;
    private final long placeTimeMillis;
    private boolean exploded;

    // We store a bomb texture region so we can draw it
    private final TextureRegion texture;

    public Bomb(int tileX, int tileY, int radius, long placeTimeMillis) {
        this.tileX = tileX;
        this.tileY = tileY;
        this.blastRadius = radius;
        this.placeTimeMillis = placeTimeMillis;
        this.exploded = false;

        // Example: if you have a BOMB texture region in your Textures class
        this.texture = Textures.BOMB;  // e.g. loaded from a spritesheet
    }

    public void update(float deltaTime, GameMap map) {
        if (!exploded) {
            float elapsed = (System.currentTimeMillis() - placeTimeMillis) / 1000f;
            if (elapsed >= FUSE_TIME_SECONDS) {
                explode(map);
            }
        }
    }

    private void explode(GameMap map) {
        exploded = true;

        // 1) Damage outward in cardinal directions
        causeBlast(map,  1,  0); // right
        causeBlast(map, -1,  0); // left
        causeBlast(map,  0,  1); // up
        causeBlast(map,  0, -1); // down

        // 2) Damage the tile the bomb is on
        damageTile(map, tileX, tileY);

        // 3) Inform the player so bomb capacity can free up
        if (map.getPlayer() != null) {
            map.getPlayer().bombHasExploded();
        }

        // Optionally: sound effect, explosion animation, etc.
    }

    private void causeBlast(GameMap map, int dx, int dy) {
        int currentX = tileX;
        int currentY = tileY;
        for (int i = 1; i <= blastRadius; i++) {
            currentX += dx;
            currentY += dy;
            if (currentX < 0 || currentX >= 40 || currentY < 0 || currentY >= 24) {
                break;
            }
            boolean blocked = damageTile(map, currentX, currentY);
            if (blocked) {
                // Indestructible or we destroyed a destructible (end blast)
                break;
            }
        }
    }

    private boolean damageTile(GameMap map, int x, int y) {
        // Check walls
        for (WallPath wall : map.getWalls()) {
            if (!wall.isDestroyed()) {
                int wx = (int) wall.getX();
                int wy = (int) wall.getY();
                if (wx == x && wy == y) {
                    if (wall.isDestructible()) {
                        wall.destroy();  // remove from Box2D, mark destroyed
                        return false;   // continue blast
                    } else {
                        return true;    // block blast
                    }
                }
            }
        }
        // Check enemies
        for (Enemy e : map.getEnemies()) {
            int ex = (int) e.getX();
            int ey = (int) e.getY();
            if (ex == x && ey == y) {
                map.getEnemies().remove(e);
                break;
            }
        }
        // Check player
        Player p = map.getPlayer();
        if (p != null) {
            int px = (int) p.getX();
            int py = (int) p.getY();
            if (px == x && py == y) {
                System.out.println("Player killed by bomb at (" + x + "," + y + ")!");
                // e.g. map.gameOver();
            }
        }
        return false; // no block
    }

    public boolean isExploded() {
        return exploded;
    }

    public void render(SpriteBatch batch) {
        if (!exploded) {
            float px = tileX * GameScreen.TILE_SIZE_PX * GameScreen.SCALE;
            float py = tileY * GameScreen.TILE_SIZE_PX * GameScreen.SCALE;
            batch.draw(texture, px, py,
                texture.getRegionWidth() * GameScreen.SCALE,
                texture.getRegionHeight() * GameScreen.SCALE
            );
        }
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Enemy.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.FixtureDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;

import de.tum.cit.ase.bomberquest.texture.Animations;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents an enemy in the game.
 * Enemies can move and interact with bombs and players.
 */
public class Enemy extends Object implements Drawable {


    private final Body body;
    private final TextureRegion textureRegion;
    private static final float ENEMY_SIZE = 1.0f;
    private float dirChangeTimer = 0f;
    private final float DIR_CHANGE_INTERVAL = 1.0f;  // how often to pick a new direction
    private Vector2 currentVelocity = new Vector2();

    private float elapsedTime;


    public Enemy() {
        super(0, 0, null);
        this.textureRegion = null;
        this.body = null;
    }

    public Enemy(World world, float x, float y, int type, TextureRegion textureRegion) {
        super(x, y, null);
        this.textureRegion = textureRegion;
        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.DynamicBody;
        bodyDef.position.set(x, y);
        body = world.createBody(bodyDef);
        body.setSleepingAllowed(false);

                CircleShape circle = new CircleShape();
        circle.setRadius(0.3f);

        FixtureDef fixtureDef = new FixtureDef();
        fixtureDef.shape = circle;
        fixtureDef.density = 1.0f;
        fixtureDef.friction = 0.5f;
        fixtureDef.restitution = 0.0f;

        body.createFixture(fixtureDef);
        body.setUserData(this);
        circle.dispose();
        }

    /**
     * Renders the enemy on the screen.
     *
     * @param batch The SpriteBatch used for rendering.
     */

    public void render(SpriteBatch batch) {
        Vector2 position = body.getPosition();
        batch.draw(textureRegion, position.x - ENEMY_SIZE / 2, position.y - ENEMY_SIZE / 2, ENEMY_SIZE, ENEMY_SIZE);
    }


    public void update(float deltaTime, GameMap map) {
        this.elapsedTime += deltaTime;
        // 1) Possibly pick a new random direction
        dirChangeTimer += deltaTime;
        if (dirChangeTimer >= DIR_CHANGE_INTERVAL) {
            dirChangeTimer = 0f;

            // random integer from 0..3 => up/down/left/right
            int dir = com.badlogic.gdx.math.MathUtils.random(3);
            switch (dir) {
                case 0: currentVelocity.set(2, 0); break;  // right
                case 1: currentVelocity.set(-2, 0); break; // left
                case 2: currentVelocity.set(0, 2); break;  // up
                case 3: currentVelocity.set(0, -2); break; // down
            }
        }

        // 2) Move according to currentVelocity
        body.setLinearVelocity(currentVelocity.x, currentVelocity.y);
        System.out.println("Enemy velocity: " + body.getLinearVelocity());
        System.out.println("Enemy position: " + body.getPosition());
        body.setAwake(true);

        // 3) Check if enemy touches the player => kill the player
        Player player = map.getPlayer();
        if (player != null) {
            float dist = body.getPosition().dst(player.getHitbox().getPosition());
            // 0.8 or 0.5 => depends how "close" is a collision.
            // We can also rely on Box2D collisions, but let's do a simple distance check.
            if (dist < 0.5f) {
                System.out.println("Player killed by enemy at " + body.getPosition());
                // e.g. do some map.gameOver() or kill the player
            }
        }
    }

    public Body getBody() {
        return body;
    }



     @Override
     public TextureRegion getCurrentAppearance() {
         // just return this.textureRegion
         return textureRegion;
     }

     @Override
     public float getX() {
         return x;  // ‘x’ is inherited from parent
     }

     @Override
     public float getY() {
         return y;
     }

}



--- File: core/src/de/tum/cit/ase/bomberquest/map/PowerUp.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents a power-up in the game.
 * Power-ups can be collected by the player to enhance abilities.
 */
public class PowerUp extends Object implements Drawable{

        private final Body body;
        private final TextureRegion textureRegion;
        private final int type; // 5 for concurrent bomb, 6 for blast radius
        private static final float POWERUP_SIZE = 1.0f;

        public PowerUp(World world, float x, float y, int type, TextureRegion textureRegion) {
            super(x, y, null);
            this.type = type;
            this.textureRegion = textureRegion;

            BodyDef bodyDef = new BodyDef();
            bodyDef.type = BodyDef.BodyType.StaticBody;
            bodyDef.position.set(x, y);


            body = world.createBody(bodyDef);


            PolygonShape shape = new PolygonShape();
            shape.setAsBox(POWERUP_SIZE / 2, POWERUP_SIZE / 2);
            body.createFixture(shape, 0.0f);
            shape.dispose();
        }



        /**
         * Renders the power-up on the screen.
         *
         * @param batch The SpriteBatch used for rendering.
         */

    public void render(SpriteBatch batch) {
        Vector2 position = body.getPosition();
        batch.draw(textureRegion, position.x - POWERUP_SIZE / 2, position.y - POWERUP_SIZE / 2, POWERUP_SIZE, POWERUP_SIZE);
    }



    /**
     * Gets the type of the power-up.
     *
     * @return The type of the power-up.
     */

    public int getType() {
        return type;
    }
    @Override
    public TextureRegion getCurrentAppearance() {
        // just return this.textureRegion
        return textureRegion;
    }

    @Override
    public float getX() {
        return x;  // ‘x’ is inherited from parent
    }

    @Override
    public float getY() {
        return y;
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/map/DestructibleWall.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.World;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * DestructibleWall is a subclass of WallPath that can be destroyed.
 */
public class DestructibleWall extends WallPath {

    /**
     * Constructs a DestructibleWall with the specified position, dimensions, and texture region.
     *
     * @param x             The initial x-coordinate of the wall.
     * @param y             The initial y-coordinate of the wall.
     * @param width         The width of the wall.
     * @param height        The height of the wall.
     * @param textureRegion The TextureRegion for the static appearance of the wall.
     */
    public DestructibleWall(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(world, x, y, width, height, textureRegion);
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return True because this is a destructible wall.
     */
    @Override
    public boolean isDestructible() {
        return true;
    }

    /**
     * Destroys the wall/path by setting the isDestroyed flag to true.
     */
    @Override
    public void destroy() {
        if (!isDestroyed) {
            this.isDestroyed = true;
            body.getWorld().destroyBody(body);
        }
    }
}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Object.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;

/**
 * The GameObject class serves as a base class for game objects in the scene.(Enemy, Entrance, Exit)
 * It extends the LibGDX Actor class and provides common properties and methods for game objects.
 *
 * @see com.badlogic.gdx.scenes.scene2d.Actor
 */
public class Object extends Actor {

    /** The x-coordinate of the game object. */
    protected float x;

    /** The y-coordinate of the game object. */
    protected float y;

    /** The width of the game object. */
    protected float width = 64;

    /** The height of the game object. */
    protected float height = 64;

    /** The animation used for dynamic game objects. */
    protected Animation<TextureRegion> animation;

    /** The current animation time for dynamic game objects. */
    protected float animationTime = 0;

    /** The sinus input used for certain animations or behaviors. */
    protected float sinusInput = 0f;

    /** The texture region representing the visual appearance of the game object. */
    protected TextureRegion textureRegion;

    /** The texture of the game object (might be null if using animation). */
    protected Texture texture;

    /** The speed of the game object (might be used in subclasses). */
    protected float speed;

    /**
     * Constructs a GameObject with the specified position, dimensions, and animation.
     *
     * @param x           The x-coordinate of the game object.
     * @param y           The y-coordinate of the game object.
     * @param animation   The animation for dynamic game objects.
     */
    public Object(float x, float y, Animation<TextureRegion> animation) {
        this.x = x;
        this.y = y;
        this.animation = animation;
    }


    /**
     * Checks if this game object collides with another game object.
     *
     * @param object  The other game object to check for collision.
     * @return True if a collision occurs, false otherwise.
     */
    public boolean collidesWith(Object object) {
        boolean above = y + height - 20 > object.getY();
        boolean below = y + 10 < object.getY() + object.getHeight();
        boolean left = x + 3 < object.getX() + object.getWidth();
        boolean right = x + width > object.getX();
        return above && below && left && right;
    }

    /**
     * Draws the game object using the specified SpriteBatch, position, dimensions, and delta time.
     *
     * @param batch   The SpriteBatch used for drawing.
     * @param x       The x-coordinate at which to draw the game object.
     * @param y       The y-coordinate at which to draw the game object.
     * @param delta   The time elapsed since the last draw.
     * @param width   The width at which to draw the game object.
     * @param height  The height at which to draw the game object.
     */
    public void draw(SpriteBatch batch, float x, float y, float delta, float width, float height) {
        animationTime += delta;
        TextureRegion currentFrame = animation.getKeyFrame(animationTime, true);
        batch.draw(currentFrame, x, y, width, height);
    }

    /**
     * Updates the game object based on the elapsed time since the last update.
     *
     * @param delta  The time elapsed since the last update.
     */
    public void update(float delta) {
    }

    // Getters and setters
    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public float getWidth() {
        return width;
    }

    public float getHeight() {
        return height;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void setWidth(float width) {
        this.width = width;
    }

    public void setHeight(float height) {
        this.height = height;
    }

    public float getSinusInput() {
        return sinusInput;
    }

    public TextureRegion getTextureRegion() {
        return textureRegion;
    }

    public Texture getTexture() {
        return texture;
    }

    public float getSpeed() {
        return speed;
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/IndestructibleWall.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.World;

/**
 * IndestructibleWall is a subclass of WallPath that cannot be destroyed.
 */
public class IndestructibleWall extends WallPath  {

    /**
     * Constructs an IndestructibleWall with the specified position, dimensions, and texture region.
     *
     * @param x             The initial x-coordinate of the wall.
     * @param y             The initial y-coordinate of the wall.
     * @param width         The width of the wall.
     * @param height        The height of the wall.
     * @param textureRegion The TextureRegion for the static appearance of the wall.
     */
    public IndestructibleWall(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(world, x, y, width, height, textureRegion);
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return False because this is an indestructible wall.
     */
    @Override
    public boolean isDestructible() {
        return false;
    }

    /**
     * Indestructible walls cannot be destroyed, so this method does nothing.
     */
    @Override
    public void destroy() {
        // No action needed for indestructible walls.
    }

}

--- File: core/src/de/tum/cit/ase/bomberquest/map/GameMap.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.World;
import de.tum.cit.ase.bomberquest.BomberQuestGame;
import de.tum.cit.ase.bomberquest.texture.Textures;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Represents the game map.
 * Holds all the objects and entities in the game.
 */
public class GameMap {

    // A static block is executed once when the class is referenced for the first time.
    static {
        // Initialize the Box2D physics engine.
        com.badlogic.gdx.physics.box2d.Box2D.init();
    }

    // Box2D physics simulation parameters (you can experiment with these if you want, but they work well as they are)
    /**
     * The time step for the physics simulation.
     * This is the amount of time that the physics simulation advances by in each frame.
     * It is set to 1/refreshRate, where refreshRate is the refresh rate of the monitor, e.g., 1/60 for 60 Hz.
     */
    private static final float TIME_STEP = 1f / Gdx.graphics.getDisplayMode().refreshRate;
    private static final int VELOCITY_ITERATIONS = 6;
    private static final int POSITION_ITERATIONS = 2;
    private float physicsTime = 0;

    private final BomberQuestGame game;
    private final World world;
    private final Player player;

    private Entrance entrance;
    private Exit exit;
    private final Chest chest; // if used
    private final Flowers[][] flowers;

    private final List<WallPath> walls;
    private List<Enemy> enemies;
    private final List<PowerUp> powerUps;
    private final List<Bomb> bombs;

    public GameMap(BomberQuestGame game) {
        this.game = game;
        this.world = new World(Vector2.Zero, true);

        this.player = new Player(this.world, 0, 0, this);
        this.enemies = new ArrayList<>();
        this.walls = new ArrayList<>();
        this.chest = null;   // or spawn if needed
        this.flowers = new Flowers[1][4];
        this.powerUps = new ArrayList<>();
        this.bombs = new ArrayList<>();
    }

    public Entrance getEntrance() {
        return entrance;
    }

    public Exit getExit() {
        return exit;
    }

    public List<Enemy> getEnemies() {
        return enemies;
    }

    public List<PowerUp> getPowerUps() {
        return powerUps;
    }


    public void tick(float frameTime) {
        // 1) Let player handle input
        player.tick(frameTime);

        // 2) Update physics (player movement, collisions)
        doPhysicsStep(frameTime);

        checkPlayerPowerUpPickup();

        // 3) Update bombs
        List<Bomb> toRemove = new ArrayList<>();
        for (Bomb bomb : bombs) {
            bomb.update(frameTime, this);
            if (bomb.isExploded()) {
                toRemove.add(bomb);
            }
        }
        bombs.removeAll(toRemove);

        // 4) Update enemies
        for (Enemy e : enemies) {
            e.update(frameTime, this);
        }

        // 5) If there's an exit, check if all enemies dead => unlock
        if (exit != null && !exit.isUnlocked() && allEnemiesDead()) {
            exit.unlockExit();
        }
    }

    private void doPhysicsStep(float frameTime) {
        physicsTime += frameTime;
        while (physicsTime >= TIME_STEP) {
            world.step(TIME_STEP, VELOCITY_ITERATIONS, POSITION_ITERATIONS);
            physicsTime -= TIME_STEP;
        }
    }

    
    private void checkPlayerPowerUpPickup() {
        // (x,y) of player, truncated or rounded to int
        int px = (int) player.getX();
        int py = (int) player.getY();
    
        // We gather all power-ups that have been picked up
        List<PowerUp> toRemove = new ArrayList<>();
    
        for (PowerUp p : powerUps) {
            int puX = (int) p.getX();
            int puY = (int) p.getY();
    
            // If same tile, pick up
            if (puX == px && puY == py) {
                // Apply effect
                applyPowerUpEffect(p);
                toRemove.add(p);
            }
        }
    
        // Remove them from the map
        powerUps.removeAll(toRemove);
    }
    
    private void applyPowerUpEffect(PowerUp p) {
        switch (p.getType()) {
            case 5:
                // concurrency bomb
                player.increaseBombCapacity();
                break;
            case 6:
                // blast radius
                player.increaseBombRadius();
                break;
        }
        // Possibly play a pickup sound effect, etc.
    }

    public void addBomb(Bomb bomb) {
        this.bombs.add(bomb);
    }

    public List<Bomb> getBombs() {
        return bombs;
    }

    private boolean allEnemiesDead() {
        return enemies.isEmpty();
    }

    /** Returns the player on the map. */
    public Player getPlayer() {
        return player;
    }

    /** Returns the chest on the map. */
    public Chest getChest() {
        return chest;
    }

    /** Returns the flowers on the map. */
    public List<Flowers> getFlowers() {
        return Arrays.stream(flowers).flatMap(Arrays::stream).toList();
    }
    public List<WallPath> getWalls() {
        return walls;
    }

    public void loadFromProperties(String relativePath) {
        String fileContent = Gdx.files.internal(relativePath).readString();
        String[] lines = fileContent.split("\\r?\\n");

        for (String line : lines) {
            line = line.trim();
            if (line.isEmpty() || line.startsWith("#")) {
                continue;
            }

            String[] parts = line.split("=");
            if (parts.length < 2) {
                continue;
            }
            String key = parts[0].trim();
            String val = parts[1].trim();

            // 5. Split key into coordinates x,y
            String[] coords = key.split(",");
            if (coords.length < 2) {
                continue; // malformed coordinates
            }
            int x = Integer.parseInt(coords[0]);
            int y = Integer.parseInt(coords[1]);

            // 6. Parse the object type
            int type = Integer.parseInt(val);

            // 7. Create objects in the Box2D world
            switch (type) {
                case 0:
                    // 0 = Indestructible wall
                    spawnIndestructibleWall(x, y);
                    break;
                case 1:
                    // 1 = Destructible wall
                    spawnDestructibleWall(x, y);
                    break;
                case 2:
                    // 2 = Entrance
                    spawnEntrance(x, y);
                    break;
                case 3:
                    // 3 = Enemy
                    spawnEnemy(x, y);
                    break;
                case 4:
                    // 4 = Exit (with destructible wall on top)
                    spawnExit(x, y);
                    break;
                case 5:
                    // 5 = Concurrent bomb power-up (also under destructible wall)
                    spawnConcurrentPowerUp(x, y);
                    break;
                case 6:
                    // 6 = Blast radius power-up (also under destructible wall)
                    spawnBlastRadiusPowerUp(x, y);
                    break;
                default:
                    System.out.println("Unknown map object type: " + type);
                    break;
            }
        }

        // 8. If no exit was found, pick a random destructible wall to hide an exit
        //    (only if you want to fulfill the rule that a map might not specify exit).
        ensureExitIfMissing();
    }

        private void spawnIndestructibleWall(int x, int y) {
        TextureRegion wallTexture = new TextureRegion(Textures.INDEST_WALL);
        float wallWidth = 1f;
        float wallHeight = 1f;
        IndestructibleWall wall = new IndestructibleWall(
            this.world, x, y,
            wallWidth, wallHeight,
            wallTexture
        );
        this.walls.add(wall);
    }

    private void spawnDestructibleWall(int x, int y) {
        TextureRegion wallTexture = new TextureRegion(Textures.DEST_WALL);
        float wallWidth = 1f;
        float wallHeight = 1f;
        DestructibleWall wall = new DestructibleWall(
            this.world, x, y,
            wallWidth, wallHeight,
            wallTexture
        );
        this.walls.add(wall);
    }

    private void spawnEntrance(int x, int y) {
        // This sets the player's spawn location or store it separately
        // If you want only 1 entrance, you could do:
        this.entrance = new Entrance(x, y, Textures.ENTRANCE);
        // Possibly position the player here
        this.player.getHitbox().setTransform(x, y, 0);
    }

    private void spawnExit(int x, int y) {
        // 1) Make a destructible wall covering (x, y)
        TextureRegion destructibleRegion = new TextureRegion(
            new Texture("assets/texture/destructablewall.png")
        );
        DestructibleWall coverWall = new DestructibleWall(
            this.world,
            x, y,
            1f, 1f,
            destructibleRegion
        );
        this.walls.add(coverWall);

        // 2) Create an Exit object referencing that wall
        //    The Exit constructor can take the same coordinates plus a reference to the wall
        //    (We pass 'null' for animation or a custom exit texture if you prefer.)
        this.exit = new Exit(x, y, Textures.EXIT, coverWall);
    }

    private void spawnEnemy(int x, int y) {
        // This is a placeholder. You might do real logic like new Enemy(world, x, y, someTexture)
        // For now, let's just store a dummy instance in enemies list.
        TextureRegion concurrencyRegion = new TextureRegion(Textures.ENEMY);
        Enemy e = new Enemy(world, x, y, 3, concurrencyRegion);
        // e.setX(x); e.setY(y); or actual Box2D logic if you prefer
        enemies.add(e);
    }

    private void spawnConcurrentPowerUp(int x, int y) {
        // For concurrency bombs, use a ‘blue’ power-up sprite or something
        TextureRegion concurrencyRegion = new TextureRegion(Textures.POWER_UP_GREEN);
        PowerUp p = new PowerUp(world, x, y, 5, concurrencyRegion);
        powerUps.add(p);
    }
    
    private void spawnBlastRadiusPowerUp(int x, int y) {
        // For blast radius bombs, use a ‘red’ power-up sprite or something else
        TextureRegion radiusRegion = new TextureRegion(Textures.POWER_UP_RED);
        PowerUp p = new PowerUp(world, x, y, 6, radiusRegion);
        powerUps.add(p);
    }
    

    private void ensureExitIfMissing() {
        // Check if you spawned an exit at all.
        // If not, pick a random destructible wall from `walls` to place an exit under it.
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/Player.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.physics.box2d.*;
import de.tum.cit.ase.bomberquest.texture.Animations;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents the player character in the game.
 * The player has a hitbox, so it can collide with other objects in the game.
 */
public class Player implements Drawable {

    /** Total time elapsed since the game started. We use this for calculating the player movement and animating it. */
    private float elapsedTime;

    /** The Box2D hitbox of the player, used for position and collision detection. */
    private final Body hitbox;

    // New fields for bombs
    private int bombCapacity = 1;    // how many bombs can be active at once
    private int bombsCurrentlyPlaced = 0;
    private int bombRadius = 1;       // default radius

    // A reference back to the GameMap so we can place bombs there.
    private final GameMap map;

    public Player(World world, float x, float y, GameMap map) {
        this.map = map;
        this.hitbox = createHitbox(world, x, y);
    }

    /**
     * Creates a Box2D body for the player.
     * This is what the physics engine uses to move the player around and detect collisions with other bodies.
     *
     * @param world  The Box2D world to add the body to.
     * @param startX The initial X position.
     * @param startY The initial Y position.
     * @return The created body.
     */
    private Body createHitbox(World world, float startX, float startY) {
        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.DynamicBody;
        bodyDef.position.set(startX, startY);
        Body body = world.createBody(bodyDef);

        CircleShape circle = new CircleShape();
        circle.setRadius(0.3f);

        FixtureDef fixtureDef = new FixtureDef();
        fixtureDef.shape = circle;
        fixtureDef.density = 1.0f;
        fixtureDef.friction = 0.5f;
        fixtureDef.restitution = 0.0f;

        body.createFixture(fixtureDef);
        body.setUserData(this);
        circle.dispose();
        return body;
    }

    /**
     * Handles movement each frame, plus checks if SPACE is pressed to place a bomb.
     */
    public void tick(float frameTime) {
        this.elapsedTime += frameTime;

        // Movement logic
        float xVelocity = 0;
        float yVelocity = 0;
        if (Gdx.input.isKeyPressed(Input.Keys.UP)) {
            yVelocity = 2;
        } else if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) {
            yVelocity = -2;
        }
        if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) {
            xVelocity = -2;
        } else if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) {
            xVelocity = 2;
        }
        this.hitbox.setLinearVelocity(xVelocity, yVelocity);

        // If pressing SPACE, try to place bomb
        if (Gdx.input.isKeyJustPressed(Input.Keys.SPACE)) {
            attemptToPlaceBomb();
        }

       System.out.println("Player velocity: " + this.hitbox.getLinearVelocity());
       System.out.println("Player position: " + this.hitbox.getPosition());
    }

    private void attemptToPlaceBomb() {
        // Only place if we haven't exceeded capacity
        if (bombsCurrentlyPlaced < bombCapacity) {
            // Round the player's float position to the nearest tile
            int bombX = Math.round(getHitbox().getPosition().x);
            int bombY = Math.round(getHitbox().getPosition().y);

            // Create and add Bomb to the GameMap
            Bomb newBomb = new Bomb(
                bombX,
                bombY,
                bombRadius,
                System.currentTimeMillis()
            );

            // Actually add the bomb to the map so it can be updated & rendered
            map.addBomb(newBomb);

            bombsCurrentlyPlaced++;
        }
    }

    /**
     * Called by the Bomb when it finishes exploding (so the Player can place another).
     */
    public void bombHasExploded() {
        bombsCurrentlyPlaced = Math.max(0, bombsCurrentlyPlaced - 1);
    }

    public void increaseBombRadius() {
        bombRadius = Math.min(bombRadius + 1, 8);
    }

    public void increaseBombCapacity() {
        bombCapacity = Math.min(bombCapacity + 1, 8);
    }

    public Body getHitbox() {
        return hitbox;
    }

    @Override
    public TextureRegion getCurrentAppearance() {
        // Get the frame of the walk down animation that corresponds to the current time.
        return Animations.CHARACTER_WALK_DOWN.getKeyFrame(this.elapsedTime, true);
    }

    @Override
    public float getX() {
        return hitbox.getPosition().x;
    }

    @Override
    public float getY() {
        return hitbox.getPosition().y;
    }

    public int getBombRadius() {
        return bombRadius;
    }

    public int getBombCapacity() {
        return bombCapacity;
    }


    public void render(SpriteBatch batch) {
        // Draw the player's current sprite at (x, y)
        batch.draw(getCurrentAppearance(), getX(), getY(), 1f, 1f);
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/map/WallPath.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.physics.box2d.*;
import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * WallPath is an abstract class that represents a wall or path in the game map.
 * It no longer uses animation, and it directly handles a static texture.
 */
public abstract class WallPath extends Object implements Drawable{

    private static final float TILE_SIZE = 32.0f;

    protected Rectangle bounds;
    protected TextureRegion textureRegion;
    protected boolean isDestroyed;
    protected final Body body;

    /**
     * Constructs a WallPath object.
     *
     * @param x             X position of the wall/path.
     * @param y             Y position of the wall/path.
     * @param width         Width of the wall/path.
     * @param height        Height of the wall/path.
     * @param textureRegion TextureRegion to render for the wall/path.
     */
    public WallPath(World world, float x, float y, float width, float height, TextureRegion textureRegion) {
        super(x, y, null);  // No animation for the wall, passing null for animation.

        if (textureRegion == null) {
            throw new IllegalArgumentException("TextureRegion cannot be null for WallPath object.");
        }
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Width and height must be positive.");
        }

        this.bounds = new Rectangle(x, y, width, height);
        this.textureRegion = textureRegion;
        this.isDestroyed = false;

        BodyDef bodyDef = new BodyDef();
        bodyDef.type = BodyDef.BodyType.StaticBody;
        bodyDef.position.set(x + width / 2, y + height / 2);
        this.body = world.createBody(bodyDef);

        PolygonShape shape = new PolygonShape();
        shape.setAsBox(width / 2, height / 2);

        FixtureDef fixtureDef = new FixtureDef();
        fixtureDef.shape = shape;
        fixtureDef.density = 1.0f;
        fixtureDef.friction = 0.5f;
        fixtureDef.restitution = 0.0f;

        this.body.createFixture(fixtureDef);
        this.body.setUserData(this);

        shape.dispose();
    }

    /**
     * Renders the wall/path if it is not destroyed.
     *
     * @param batch The SpriteBatch used to draw the texture.
     */
    @Override
    public void draw(SpriteBatch batch, float x, float y, float delta, float width, float height) {
        if (!isDestroyed && textureRegion != null) {
            batch.draw(textureRegion, x, y, width, height);
        }
    }

    /**
     * Determines if the wall/path is destructible.
     *
     * @return True if destructible, false otherwise.
     */
    public abstract boolean isDestructible();

    /**
     * Destroys the wall/path, if applicable.
     */
    public abstract void destroy();

    /**
     * Gets the bounding rectangle for collision or placement purposes.
     *
     * @return The bounds of the wall/path.
     */
    public Rectangle getBounds() {
        return bounds;
    }

    /**
     * Checks if the wall/path has been destroyed.
     *
     * @return True if destroyed, false otherwise.
     */
    public boolean isDestroyed() {
        return isDestroyed;
    }

    /**
     * Disposes of resources associated with this wall/path.
     */
    public void dispose() {
        if (textureRegion != null) {
            // Optionally dispose the texture associated with the texture region
            textureRegion.getTexture().dispose();
        }
    }
    public TextureRegion getCurrentAppearance() {
        return textureRegion;
    }

}

--- File: core/src/de/tum/cit/ase/bomberquest/map/Exit.java ---

package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;

import de.tum.cit.ase.bomberquest.texture.Drawable;

/**
 * Represents the exit point in the game.
 */
public class Exit extends Object implements Drawable {
    /** A flag indicating whether the exit has been unlocked (all enemies defeated). */
    private boolean unlocked;

    /** A flag indicating whether the exit is revealed after the wall is destroyed. */
    private boolean revealed;

    /** The wall above the exit (a destructible wall). */
    private WallPath wallAboveExit;

    /**
     * Constructs an Exit object with the specified position, dimensions, animation, and wall above it.
     *
     * @param x           The x-coordinate of the exit.
     * @param y           The y-coordinate of the exit.
     * @param textureRegion  The animation representing the exit's appearance.
     * @param wallAboveExit  The wall above the exit that must be destroyed to reveal the exit.
     */
    public Exit(float x, float y, TextureRegion textureRegion, WallPath wallAboveExit) {
        super(x, y, null);
        this.textureRegion = textureRegion; // Set the visual representation of the entrance.
        this.width = 64; // Default width
        this.height = 64; // Default height
        this.wallAboveExit = wallAboveExit;
        this.unlocked = false;
        this.revealed = false;
    }

    /**
     * Unlocks the exit after all enemies are defeated in the maze.
     */
    public void unlockExit() {
        this.unlocked = true;
    }

    /**
     * Reveals the exit by destroying the wall above it.
     */
    public void revealExit() {
        if (wallAboveExit != null && wallAboveExit.isDestroyed()) {
            this.revealed = true;
        }
    }

    /**
     * Checks if the exit is accessible (unlocked and revealed).
     *
     * @return True if the exit is unlocked and revealed, false otherwise.
     */
    public boolean isAccessible() {
        return unlocked && revealed;
    }

    /**
     * Updates the exit based on the elapsed time since the last update.
     * This method also checks if the wall above it is destroyed and updates the revealed status.
     *
     * @param delta  The time elapsed since the last update.
     */
    @Override
    public void update(float delta) {
        super.update(delta);
        // Check if the exit should be revealed after the wall is destroyed.
        revealExit();
    }

    /**
     * Renders the exit using the specified SpriteBatch.
     * If the exit is revealed, the exit will be drawn.
     * If not, the exit will remain hidden beneath the destructible wall.
     *
     * @param spriteBatch  The SpriteBatch used for rendering.
     */
    @Override
    public void draw(SpriteBatch spriteBatch, float x, float y, float delta, float width, float height) {
        if (revealed && isAccessible()) {
            // Draw the exit only if it's revealed and accessible
            super.draw(spriteBatch, x, y, delta, width, height);
        }
    }

    // Getters and setters
    public boolean isUnlocked() {
        return unlocked;
    }

    public boolean isRevealed() {
        return revealed;
    }

    public WallPath getWallAboveExit() {
        return wallAboveExit;
    }

    public void setWallAboveExit(WallPath wallAboveExit) {
        this.wallAboveExit = wallAboveExit;
    }
    @Override
    public TextureRegion getCurrentAppearance() {
        // just return this.textureRegion
        return textureRegion;
    }

    @Override
    public float getX() {
        return x;  // ‘x’ is inherited from parent
    }

    @Override
    public float getY() {
        return y;
    }
}


--- File: core/src/de/tum/cit/ase/bomberquest/screen/GameScreen.java ---

package de.tum.cit.ase.bomberquest.screen;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.ScreenUtils;
import de.tum.cit.ase.bomberquest.BomberQuestGame;
import de.tum.cit.ase.bomberquest.map.Bomb;
import de.tum.cit.ase.bomberquest.map.Enemy;
import de.tum.cit.ase.bomberquest.map.Flowers;
import de.tum.cit.ase.bomberquest.map.Player;
import de.tum.cit.ase.bomberquest.map.PowerUp;
import de.tum.cit.ase.bomberquest.map.WallPath;
import de.tum.cit.ase.bomberquest.texture.Drawable;
import de.tum.cit.ase.bomberquest.map.GameMap;

/**
 * The GameScreen class is responsible for rendering the gameplay screen.
 * It handles the game logic and rendering of the game elements.
 */
public class GameScreen implements Screen {
    
    /**
     * The size of a grid cell in pixels.
     * This allows us to think of coordinates in terms of square grid tiles
     * (e.g. x=1, y=1 is the bottom left corner of the map)
     * rather than absolute pixel coordinates.
     */
    public static final int TILE_SIZE_PX =16;
    
    /**
     * The scale of the game.
     * This is used to make everything in the game look bigger or smaller.
     */
    public static final int SCALE = 2;

    private final BomberQuestGame game;
    private final SpriteBatch spriteBatch;
    private final GameMap map;
    private final Hud hud;
    private final OrthographicCamera mapCamera;
    // For countdown
    private float levelTime = 150f; // 5 minutes


    /**
     * Constructor for GameScreen. Sets up the camera and font.
     *
     * @param game The main game class, used to access global resources and methods.
     */
    public GameScreen(BomberQuestGame game) {
        this.game = game;
        this.spriteBatch = game.getSpriteBatch();
        this.map = game.getMap();
        // Create and configure the camera for the game view
        this.mapCamera = new OrthographicCamera();
        this.mapCamera.setToOrtho(false);
        // Create the HUD and pass references it needs
        this.hud = new Hud(game.getSpriteBatch(), game.getSkin().getFont("font"), this.map);
    }
    
    /**
     * The render method is called every frame to render the game.
     * @param deltaTime The time in seconds since the last render.
     */
    @Override
    public void render(float deltaTime) {
        // Check for escape key press to go back to the menu
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            game.goToMenu();
        }
        
        // Clear the previous frame from the screen, or else the picture smears
        ScreenUtils.clear(Color.WHITE);

         // Decrement countdown
         levelTime -= deltaTime;
         if (levelTime < 0f) {
             levelTime = 0f;
         }
        
        // Cap frame time to 250ms to prevent spiral of death
        float frameTime = Math.min(deltaTime, 0.250f);
        
        // Update the map state
        map.tick(frameTime);
        
        // Update the camera
        updateCamera();

        // Render the map
        game.getSpriteBatch().setProjectionMatrix(mapCamera.combined);
        game.getSpriteBatch().begin();
        
        // Render the map on the screen
        renderMap();

        game.getSpriteBatch().end();

        // Finally, render the HUD on top
        hud.setTimeRemaining(levelTime); // pass updated time to the HUD
        
        // Render the HUD on the screen
        hud.render();


    }


    /**
     * Updates the camera to match the current state of the game.
     * Currently, this just centers the camera at the origin.
     */
    private void updateCamera() {
        mapCamera.setToOrtho(false);
        mapCamera.position.x = 19.5f * TILE_SIZE_PX * SCALE;
        mapCamera.position.y = 11.5f * TILE_SIZE_PX * SCALE;
        mapCamera.update();
    }
    
    private void renderMap() {
        // This configures the spriteBatch to use the camera's perspective when rendering
        spriteBatch.setProjectionMatrix(mapCamera.combined);


    if (map.getChest() != null) {
        draw(spriteBatch, map.getChest());
    }

    // Player should never be null if you instantiate it, but just in case:
    if (map.getPlayer() != null) {
        draw(spriteBatch, map.getPlayer());
    }

    for (PowerUp p : map.getPowerUps()) {
        draw(spriteBatch, p);
    }

    // For walls, skip null entries
    for (WallPath wall : map.getWalls()) {
        if (wall != null) {
            draw(spriteBatch, wall);
        }
    }

    for (Bomb b : map.getBombs()) {
        b.render(spriteBatch);
    }

    if (map.getEntrance() != null) {
        draw(spriteBatch, map.getEntrance());
    }
    for (Enemy e : map.getEnemies()) {
        draw(spriteBatch, e);
    }

    draw(spriteBatch, map.getExit());
    }
    /**
     * Draws this object on the screen.
     * The texture will be scaled by the game scale and the tile size.
     * This should only be called between spriteBatch.begin() and spriteBatch.end(), e.g. in the renderMap() method.
     * @param spriteBatch The SpriteBatch to draw with.
     */
    private static void draw(SpriteBatch spriteBatch, Drawable drawable) {
        if (drawable instanceof WallPath wall && wall.isDestroyed()) {
            return; // Skip drawing destroyed walls
        }
        TextureRegion texture = drawable.getCurrentAppearance();

        if (texture == null) {
            System.out.println("DEBUG: getCurrentAppearance() is null for " + drawable.getClass().getSimpleName()
                + " => x=" + drawable.getX() + " y=" + drawable.getY());
            return;  // skip drawing, avoid NPE
        }

        float x, y;
        if (drawable instanceof Player) {
            Player player = (Player) drawable;
            x = player.getX() * TILE_SIZE_PX * SCALE - 0.3f * TILE_SIZE_PX * SCALE; // Adjust for radius
            y = player.getY() * TILE_SIZE_PX * SCALE - 0.3f * TILE_SIZE_PX * SCALE;
        } else {
            x = drawable.getX() * TILE_SIZE_PX * SCALE;
            y = drawable.getY() * TILE_SIZE_PX * SCALE;
        }

        float width = texture.getRegionWidth() * SCALE;
        float height = texture.getRegionHeight() * SCALE;
        spriteBatch.draw(texture, x, y, width, height);
    }
    
    /**
     * Called when the window is resized.
     * This is where the camera is updated to match the new window size.
     * @param width The new window width.
     * @param height The new window height.
     */
    @Override
    public void resize(int width, int height) {
        mapCamera.setToOrtho(false);
        hud.resize(width, height);
    }

    // Unused methods from the Screen interface
    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void show() {

    }

    @Override
    public void hide() {
    }

    @Override
    public void dispose() {
    }

}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Drawable.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Represents something that can be drawn on the screen.
 * NOTE: The position returned by {@link #getX()} and {@link #getY()} is the
 * position of the BOTTOM LEFT CORNER of the texture in the game.
 */
public interface Drawable {
    
    /**
     * Gets the current appearance of the Drawable.
     * This can change over time.
     * @return The current appearance as a {@link TextureRegion}.
     */
    TextureRegion getCurrentAppearance();
    
    /**
     * Gets the X coordinate of the drawable in the game world grid.
     * Note that this is a TILE coordinate, not a pixel coordinate.
     * It must be multiplied by {@link de.tum.cit.ase.bomberquest.screen.GameScreen#TILE_SIZE_PX}
     * and {@link de.tum.cit.ase.bomberquest.screen.GameScreen#SCALE} to get the pixel coordinate.
     * @return The X coordinate of the drawable.
     */
    float getX();
    
    /**
     * Gets the Y coordinate of the drawable in the game world grid.
     * Note that this is a TILE coordinate, not a pixel coordinate.
     * It must be multiplied by {@link de.tum.cit.ase.bomberquest.screen.GameScreen#TILE_SIZE_PX}
     * and {@link de.tum.cit.ase.bomberquest.screen.GameScreen#SCALE} to get the pixel coordinate.
     * @return The Y coordinate of the drawable.
     */
    float getY();
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Textures.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Contains all texture constants used in the game.
 * It is good practice to keep all textures and animations in constants to avoid loading them multiple times.
 * These can be referenced anywhere they are needed.
 */
public class Textures {
    
    public static final TextureRegion FLOWERS = SpriteSheet.BASIC_TILES.at(2, 5);
    public static final TextureRegion DEST_WALL = SpriteSheet.BASIC_TILES.at(1,4 );
    public static final TextureRegion INDEST_WALL = SpriteSheet.BASIC_TILES.at(1,6 );
    public static final TextureRegion CHEST = SpriteSheet.BASIC_TILES.at(5, 5);
    public static final TextureRegion ENTRANCE = SpriteSheet.BASIC_TILES.at(4, 6);
    public static final TextureRegion EXIT = SpriteSheet.BASIC_TILES.at(2,4);
    public static final TextureRegion POWER_UP_GREEN = SpriteSheet.BASIC_TILES.at(3,4);
    public static final TextureRegion POWER_UP_RED = SpriteSheet.BASIC_TILES.at(3,2);
    public static final TextureRegion ENEMY = SpriteSheet.ORIGINAL_BOMBERMAN.at(22,1);
    public static final TextureRegion BOMB = SpriteSheet.BASIC_TILES.at(3, 3);
    
}



--- File: core/src/de/tum/cit/ase/bomberquest/texture/SpriteSheet.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

import de.tum.cit.ase.bomberquest.map.PowerUp;

/**
 * Enumerates all spritesheets used in the game and provides helper methods for grabbing texture regions from them.
 * It is assumed that every spritesheet has some standard grid size which can be used for easier coordinate specification.
 * See the assets/texture folder for the actual texture files (plus some more samples which are not enumerated here).
 * Feel free to add your own spritesheets and use them in the game!
 *
 * @see Texture a whole image
 * @see TextureRegion a part of an image
 */
public enum SpriteSheet {
    
    /** The character spritesheet, which has a grid size of 16x32. */
    CHARACTER("character.png", 16, 20),
    /** The basic tiles spritesheet, which has a grid size of 16x16. */
    BASIC_TILES("basictiles.png", 16, 16),

    POWER_UP("powerup.png", 16, 16),

    ORIGINAL_BOMBERMAN("original-bomberman.png", 16, 16);
    
private final Texture spritesheet;
    private final int width;
    private final int height;
    
    /**
     * Constructor for each variant of this enum.
     * Every SpriteSheet has a corresponding file, width, and height.
     * @param filename the filename of the spritesheet
     * @param width the width of a single grid cell
     * @param height the height of a single grid cell
     */
    SpriteSheet(String filename, int width, int height) {
        this.spritesheet = new Texture(Gdx.files.internal("texture/" + filename));
        this.width = width;
        this.height = height;
    }
    
    /**
     * Returns the TextureRegion at the specified row and column (1-based coordinates)
     * according to the grid specified by {@code this.width} and {@code this.height}.
     * This method assumes the size of the texture to be a single grid cell.
     * Keep in mind that since spritesheet textures typically start in the top-left corner,
     * the row index starts at 1 at the top and the column index starts at 1 on the left.
     *
     * @param row the row of the texture to fetch, starting from 1 at the TOP of the spritesheet
     * @param column the column of the texture to fetch, starting from 1 on the LEFT of the spritesheet
     * @return the texture
     */
    public TextureRegion at(int row, int column) {
        return new TextureRegion(
                spritesheet,
                (column - 1) * this.width,
                (row - 1) * this.height,
                this.width,
                this.height
        );
    }
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/texture/Animations.java ---

package de.tum.cit.ase.bomberquest.texture;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

/**
 * Contains all animation constants used in the game.
 * It is good practice to keep all textures and animations in constants to avoid loading them multiple times.
 * These can be referenced anywhere they are needed.
 */
public class Animations {
    
    /**
     * The animation for the character walking down.
     */
    public static final Animation<TextureRegion> CHARACTER_WALK_DOWN = new Animation<>(0.1f,
            SpriteSheet.CHARACTER.at(1, 1),
            SpriteSheet.CHARACTER.at(1, 2),
            SpriteSheet.CHARACTER.at(1, 3),
            SpriteSheet.CHARACTER.at(1, 4)
    );
    
}


--- File: core/src/de/tum/cit/ase/bomberquest/entities/Bomb.java ---

package de.tum.cit.ase.bomberquest.entities;

public class Bomb {
}
